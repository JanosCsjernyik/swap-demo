'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var globalAxios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var globalAxios__default = /*#__PURE__*/_interopDefaultLegacy(globalAxios);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* tslint:disable */
const BASE_PATH = "http://localhost".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios__default['default']) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}

/* tslint:disable */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
const NodeStatusEnum = {
    Active: 'Active',
    Whitelisted: 'Whitelisted',
    Standby: 'Standby',
    Disabled: 'Disabled'
};
const ObservedTxStatusEnum = {
    Done: 'done',
    Incomplete: 'incomplete'
};
const VaultTypeEnum = {
    AsgardVault: 'AsgardVault',
    YggdrasilVault: 'YggdrasilVault'
};
/**
 * BucketsApi - axios parameter creator
 * @export
 */
const BucketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucket: (asset, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('bucket', 'asset', asset);
            const localVarPath = `/thorchain/bucket/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buckets: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BucketsApi - functional programming interface
 * @export
 */
const BucketsApiFp = function (configuration) {
    const localVarAxiosParamCreator = BucketsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucket(asset, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.bucket(asset, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buckets(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.buckets(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * BucketsApi - factory interface
 * @export
 */
const BucketsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BucketsApiFp(configuration);
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucket(asset, height, options) {
            return localVarFp.bucket(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buckets(height, options) {
            return localVarFp.buckets(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BucketsApi - object-oriented interface
 * @export
 * @class BucketsApi
 * @extends {BaseAPI}
 */
class BucketsApi extends BaseAPI {
    /**
     * Returns the bucket information for the provided asset.
     * @param {string} asset
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    bucket(asset, height, options) {
        return BucketsApiFp(this.configuration).bucket(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the bucket information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    buckets(height, options) {
        return BucketsApiFp(this.configuration).buckets(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * HealthApi - axios parameter creator
 * @export
 */
const HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * HealthApi - functional programming interface
 * @export
 */
const HealthApiFp = function (configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * HealthApi - factory interface
 * @export
 */
const HealthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = HealthApiFp(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    ping(options) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LiquidityProvidersApi - axios parameter creator
 * @export
 */
const LiquidityProvidersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider: (asset, address, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProvider', 'asset', asset);
            // verify required parameter 'address' is not null or undefined
            assertParamExists('liquidityProvider', 'address', address);
            const localVarPath = `/thorchain/pool/{asset}/liquidity_provider/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders: (asset, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProviders', 'asset', asset);
            const localVarPath = `/thorchain/pool/{asset}/liquidity_providers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * LiquidityProvidersApi - functional programming interface
 * @export
 */
const LiquidityProvidersApiFp = function (configuration) {
    const localVarAxiosParamCreator = LiquidityProvidersApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider(asset, address, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.liquidityProvider(asset, address, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders(asset, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.liquidityProviders(asset, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * LiquidityProvidersApi - factory interface
 * @export
 */
const LiquidityProvidersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LiquidityProvidersApiFp(configuration);
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider(asset, address, height, options) {
            return localVarFp.liquidityProvider(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders(asset, height, options) {
            return localVarFp.liquidityProviders(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LiquidityProvidersApi - object-oriented interface
 * @export
 * @class LiquidityProvidersApi
 * @extends {BaseAPI}
 */
class LiquidityProvidersApi extends BaseAPI {
    /**
     * Returns the liquidity provider information for an address and asset.
     * @param {string} asset
     * @param {string} address
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    liquidityProvider(asset, address, height, options) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProvider(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all liquidity provider information for an asset.
     * @param {string} asset
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    liquidityProviders(asset, height, options) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProviders(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MimirApi - axios parameter creator
 * @export
 */
const MimirApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/mimir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/mimir/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey: (key, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('mimirKey', 'key', key);
            const localVarPath = `/thorchain/mimir/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode: (address, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('mimirNode', 'address', address);
            const localVarPath = `/thorchain/mimir/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/mimir/nodes_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * MimirApi - functional programming interface
 * @export
 */
const MimirApiFp = function (configuration) {
    const localVarAxiosParamCreator = MimirApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mimir(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mimirAdmin(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey(key, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mimirKey(key, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode(address, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mimirNode(address, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mimirNodes(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * MimirApi - factory interface
 * @export
 */
const MimirApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MimirApiFp(configuration);
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir(height, options) {
            return localVarFp.mimir(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin(height, options) {
            return localVarFp.mimirAdmin(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey(key, height, options) {
            return localVarFp.mimirKey(key, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode(address, height, options) {
            return localVarFp.mimirNode(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes(height, options) {
            return localVarFp.mimirNodes(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MimirApi - object-oriented interface
 * @export
 * @class MimirApi
 * @extends {BaseAPI}
 */
class MimirApi extends BaseAPI {
    /**
     * Returns current active mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    mimir(height, options) {
        return MimirApiFp(this.configuration).mimir(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current admin mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    mimirAdmin(height, options) {
        return MimirApiFp(this.configuration).mimirAdmin(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current active mimir configuration for the provided key.
     * @param {string} key the mimir key to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    mimirKey(key, height, options) {
        return MimirApiFp(this.configuration).mimirKey(key, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current node mimir configuration for the provided node address.
     * @param {string} address
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    mimirNode(address, height, options) {
        return MimirApiFp(this.configuration).mimirNode(address, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current node mimir votes.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    mimirNodes(height, options) {
        return MimirApiFp(this.configuration).mimirNodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NetworkApi - axios parameter creator
 * @export
 */
const NetworkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban: (address, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('ban', 'address', address);
            const localVarPath = `/thorchain/ban/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain: (chain, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('lastblockChain', 'chain', chain);
            const localVarPath = `/thorchain/lastblock/{chain}`
                .replace(`{${"chain"}}`, encodeURIComponent(String(chain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/ragnarok`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NetworkApi - functional programming interface
 * @export
 */
const NetworkApiFp = function (configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(address, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ban(address, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.constants(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.inboundAddresses(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lastblock(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain(chain, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lastblockChain(chain, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.network(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ragnarok(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.version(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * NetworkApi - factory interface
 * @export
 */
const NetworkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NetworkApiFp(configuration);
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(address, height, options) {
            return localVarFp.ban(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants(height, options) {
            return localVarFp.constants(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses(height, options) {
            return localVarFp.inboundAddresses(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock(height, options) {
            return localVarFp.lastblock(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain(chain, height, options) {
            return localVarFp.lastblockChain(chain, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network(height, options) {
            return localVarFp.network(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok(height, options) {
            return localVarFp.ragnarok(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(height, options) {
            return localVarFp.version(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
class NetworkApi extends BaseAPI {
    /**
     * Returns the ban status for the provided node address.
     * @param {string} address
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    ban(address, height, options) {
        return NetworkApiFp(this.configuration).ban(address, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns constant configuration, can be overridden by mimir.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    constants(height, options) {
        return NetworkApiFp(this.configuration).constants(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the set of asgard addresses that should be used for inbound transactions.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    inboundAddresses(height, options) {
        return NetworkApiFp(this.configuration).inboundAddresses(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the last block information for all chains.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    lastblock(height, options) {
        return NetworkApiFp(this.configuration).lastblock(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the last block information for the provided chain.
     * @param {string} chain
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    lastblockChain(chain, height, options) {
        return NetworkApiFp(this.configuration).lastblockChain(chain, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns network overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    network(height, options) {
        return NetworkApiFp(this.configuration).network(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a boolean indicating whether the chain is in ragnarok.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    ragnarok(height, options) {
        return NetworkApiFp(this.configuration).ragnarok(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    version(height, options) {
        return NetworkApiFp(this.configuration).version(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NodesApi - axios parameter creator
 * @export
 */
const NodesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node: (address, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('node', 'address', address);
            const localVarPath = `/thorchain/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NodesApi - functional programming interface
 * @export
 */
const NodesApiFp = function (configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node(address, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.node(address, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.nodes(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * NodesApi - factory interface
 * @export
 */
const NodesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NodesApiFp(configuration);
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node(address, height, options) {
            return localVarFp.node(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes(height, options) {
            return localVarFp.nodes(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
class NodesApi extends BaseAPI {
    /**
     * Returns node information for the provided node address.
     * @param {string} address
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    node(address, height, options) {
        return NodesApiFp(this.configuration).node(address, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns node information for all registered validators.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    nodes(height, options) {
        return NodesApiFp(this.configuration).nodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * POLApi - axios parameter creator
 * @export
 */
const POLApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/pol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * POLApi - functional programming interface
 * @export
 */
const POLApiFp = function (configuration) {
    const localVarAxiosParamCreator = POLApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pol(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * POLApi - factory interface
 * @export
 */
const POLApiFactory = function (configuration, basePath, axios) {
    const localVarFp = POLApiFp(configuration);
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol(height, options) {
            return localVarFp.pol(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * POLApi - object-oriented interface
 * @export
 * @class POLApi
 * @extends {BaseAPI}
 */
class POLApi extends BaseAPI {
    /**
     * Returns protocol owned liquidity overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POLApi
     */
    pol(height, options) {
        return POLApiFp(this.configuration).pol(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PoolsApi - axios parameter creator
 * @export
 */
const PoolsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: (asset, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pool', 'asset', asset);
            const localVarPath = `/thorchain/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * PoolsApi - functional programming interface
 * @export
 */
const PoolsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(asset, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pool(asset, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pools(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * PoolsApi - factory interface
 * @export
 */
const PoolsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PoolsApiFp(configuration);
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(asset, height, options) {
            return localVarFp.pool(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools(height, options) {
            return localVarFp.pools(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
class PoolsApi extends BaseAPI {
    /**
     * Returns the pool information for the provided asset.
     * @param {string} asset
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    pool(asset, height, options) {
        return PoolsApiFp(this.configuration).pool(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the pool information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    pools(height, options) {
        return PoolsApiFp(this.configuration).pools(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * QueueApi - axios parameter creator
 * @export
 */
const QueueApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/queue/outbound`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/queue/scheduled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * QueueApi - functional programming interface
 * @export
 */
const QueueApiFp = function (configuration) {
    const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.queue(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.queueOutbound(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.queueScheduled(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * QueueApi - factory interface
 * @export
 */
const QueueApiFactory = function (configuration, basePath, axios) {
    const localVarFp = QueueApiFp(configuration);
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue(height, options) {
            return localVarFp.queue(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound(height, options) {
            return localVarFp.queueOutbound(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled(height, options) {
            return localVarFp.queueScheduled(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
class QueueApi extends BaseAPI {
    /**
     * Returns queue statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    queue(height, options) {
        return QueueApiFp(this.configuration).queue(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the outbound queue including estimated RUNE values.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    queueOutbound(height, options) {
        return QueueApiFp(this.configuration).queueOutbound(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the scheduled queue.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    queueScheduled(height, options) {
        return QueueApiFp(this.configuration).queueScheduled(height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TSSApi - axios parameter creator
 * @export
 */
const TSSApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysign', 'height', height);
            const localVarPath = `/thorchain/keysign/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height
         * @param {string} pubkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey: (height, pubkey, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysignPubkey', 'height', height);
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('keysignPubkey', 'pubkey', pubkey);
            const localVarPath = `/thorchain/keysign/{height}/{pubkey}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen: (pubkey, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('metricsKeygen', 'pubkey', pubkey);
            const localVarPath = `/thorchain/metric/keygen/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TSSApi - functional programming interface
 * @export
 */
const TSSApiFp = function (configuration) {
    const localVarAxiosParamCreator = TSSApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.keysign(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height
         * @param {string} pubkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey(height, pubkey, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.keysignPubkey(height, pubkey, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.metrics(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen(pubkey, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.metricsKeygen(pubkey, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * TSSApi - factory interface
 * @export
 */
const TSSApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TSSApiFp(configuration);
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign(height, options) {
            return localVarFp.keysign(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height
         * @param {string} pubkey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey(height, pubkey, options) {
            return localVarFp.keysignPubkey(height, pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(height, options) {
            return localVarFp.metrics(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen(pubkey, height, options) {
            return localVarFp.metricsKeygen(pubkey, height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TSSApi - object-oriented interface
 * @export
 * @class TSSApi
 * @extends {BaseAPI}
 */
class TSSApi extends BaseAPI {
    /**
     * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
     * @param {number} height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    keysign(height, options) {
        return TSSApiFp(this.configuration).keysign(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
     * @param {number} height
     * @param {string} pubkey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    keysignPubkey(height, pubkey, options) {
        return TSSApiFp(this.configuration).keysignPubkey(height, pubkey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns keygen and keysign metrics for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    metrics(height, options) {
        return TSSApiFp(this.configuration).metrics(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns keygen metrics for the provided vault pubkey.
     * @param {string} pubkey
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    metricsKeygen(pubkey, height, options) {
        return TSSApiFp(this.configuration).metricsKeygen(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ThornamesApi - axios parameter creator
 * @export
 */
const ThornamesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname: (name, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('thorname', 'name', name);
            const localVarPath = `/thorchain/thorname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ThornamesApi - functional programming interface
 * @export
 */
const ThornamesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ThornamesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname(name, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.thorname(name, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ThornamesApi - factory interface
 * @export
 */
const ThornamesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ThornamesApiFp(configuration);
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname(name, height, options) {
            return localVarFp.thorname(name, height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ThornamesApi - object-oriented interface
 * @export
 * @class ThornamesApi
 * @extends {BaseAPI}
 */
class ThornamesApi extends BaseAPI {
    /**
     * Returns addresses registered to the provided thorname.
     * @param {string} name the thornode to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThornamesApi
     */
    thorname(name, height, options) {
        return ThornamesApiFp(this.configuration).thorname(name, height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx: (hash, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('tx', 'hash', hash);
            const localVarPath = `/thorchain/tx/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners: (hash, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txSigners', 'hash', hash);
            const localVarPath = `/thorchain/tx/{hash}/signers`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(hash, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tx(hash, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners(hash, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.txSigners(hash, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TransactionsApiFp(configuration);
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(hash, height, options) {
            return localVarFp.tx(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners(hash, height, options) {
            return localVarFp.txSigners(hash, height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Returns the observed transaction for a provided inbound or outbound hash.
     * @param {string} hash
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    tx(hash, height, options) {
        return TransactionsApiFp(this.configuration).tx(hash, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the signers for a provided inbound or outbound hash.
     * @param {string} hash
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txSigners(hash, height, options) {
        return TransactionsApiFp(this.configuration).txSigners(hash, height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VaultsApi - axios parameter creator
 * @export
 */
const VaultsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/vaults/asgard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault: (pubkey, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('vault', 'pubkey', pubkey);
            const localVarPath = `/thorchain/vaults/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/vaults/pubkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil: (height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/thorchain/vaults/yggdrasil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VaultsApi - functional programming interface
 * @export
 */
const VaultsApiFp = function (configuration) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.asgard(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(pubkey, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vault(pubkey, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vaultPubkeys(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil(height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.yggdrasil(height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * VaultsApi - factory interface
 * @export
 */
const VaultsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VaultsApiFp(configuration);
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard(height, options) {
            return localVarFp.asgard(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(pubkey, height, options) {
            return localVarFp.vault(pubkey, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys(height, options) {
            return localVarFp.vaultPubkeys(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil(height, options) {
            return localVarFp.yggdrasil(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
class VaultsApi extends BaseAPI {
    /**
     * Returns current asgard vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    asgard(height, options) {
        return VaultsApiFp(this.configuration).asgard(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the vault for the provided pubkey.
     * @param {string} pubkey
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    vault(pubkey, height, options) {
        return VaultsApiFp(this.configuration).vault(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all pubkeys for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    vaultPubkeys(height, options) {
        return VaultsApiFp(this.configuration).vaultPubkeys(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current yggdrasil vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    yggdrasil(height, options) {
        return VaultsApiFp(this.configuration).yggdrasil(height, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Thornode API
 * Thornode REST API.
 *
 * The version of the OpenAPI document: 1.97.2
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

const THORNODE_API_9R_URL = 'https://thornode.ninerealms.com/';

exports.BucketsApi = BucketsApi;
exports.BucketsApiAxiosParamCreator = BucketsApiAxiosParamCreator;
exports.BucketsApiFactory = BucketsApiFactory;
exports.BucketsApiFp = BucketsApiFp;
exports.Configuration = Configuration;
exports.HealthApi = HealthApi;
exports.HealthApiAxiosParamCreator = HealthApiAxiosParamCreator;
exports.HealthApiFactory = HealthApiFactory;
exports.HealthApiFp = HealthApiFp;
exports.LiquidityProvidersApi = LiquidityProvidersApi;
exports.LiquidityProvidersApiAxiosParamCreator = LiquidityProvidersApiAxiosParamCreator;
exports.LiquidityProvidersApiFactory = LiquidityProvidersApiFactory;
exports.LiquidityProvidersApiFp = LiquidityProvidersApiFp;
exports.MimirApi = MimirApi;
exports.MimirApiAxiosParamCreator = MimirApiAxiosParamCreator;
exports.MimirApiFactory = MimirApiFactory;
exports.MimirApiFp = MimirApiFp;
exports.NetworkApi = NetworkApi;
exports.NetworkApiAxiosParamCreator = NetworkApiAxiosParamCreator;
exports.NetworkApiFactory = NetworkApiFactory;
exports.NetworkApiFp = NetworkApiFp;
exports.NodeStatusEnum = NodeStatusEnum;
exports.NodesApi = NodesApi;
exports.NodesApiAxiosParamCreator = NodesApiAxiosParamCreator;
exports.NodesApiFactory = NodesApiFactory;
exports.NodesApiFp = NodesApiFp;
exports.ObservedTxStatusEnum = ObservedTxStatusEnum;
exports.POLApi = POLApi;
exports.POLApiAxiosParamCreator = POLApiAxiosParamCreator;
exports.POLApiFactory = POLApiFactory;
exports.POLApiFp = POLApiFp;
exports.PoolsApi = PoolsApi;
exports.PoolsApiAxiosParamCreator = PoolsApiAxiosParamCreator;
exports.PoolsApiFactory = PoolsApiFactory;
exports.PoolsApiFp = PoolsApiFp;
exports.QueueApi = QueueApi;
exports.QueueApiAxiosParamCreator = QueueApiAxiosParamCreator;
exports.QueueApiFactory = QueueApiFactory;
exports.QueueApiFp = QueueApiFp;
exports.THORNODE_API_9R_URL = THORNODE_API_9R_URL;
exports.TSSApi = TSSApi;
exports.TSSApiAxiosParamCreator = TSSApiAxiosParamCreator;
exports.TSSApiFactory = TSSApiFactory;
exports.TSSApiFp = TSSApiFp;
exports.ThornamesApi = ThornamesApi;
exports.ThornamesApiAxiosParamCreator = ThornamesApiAxiosParamCreator;
exports.ThornamesApiFactory = ThornamesApiFactory;
exports.ThornamesApiFp = ThornamesApiFp;
exports.TransactionsApi = TransactionsApi;
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
exports.TransactionsApiFactory = TransactionsApiFactory;
exports.TransactionsApiFp = TransactionsApiFp;
exports.VaultTypeEnum = VaultTypeEnum;
exports.VaultsApi = VaultsApi;
exports.VaultsApiAxiosParamCreator = VaultsApiAxiosParamCreator;
exports.VaultsApiFactory = VaultsApiFactory;
exports.VaultsApiFp = VaultsApiFp;
