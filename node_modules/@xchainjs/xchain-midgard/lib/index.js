'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var globalAxios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var globalAxios__default = /*#__PURE__*/_interopDefaultLegacy(globalAxios);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* tslint:disable */
const BASE_PATH = "http://localhost".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios__default['default']) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}

/* tslint:disable */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
const ActionStatusEnum = {
    Success: 'success',
    Pending: 'pending'
};
const ActionTypeEnum = {
    Swap: 'swap',
    AddLiquidity: 'addLiquidity',
    Withdraw: 'withdraw',
    Donate: 'donate',
    Refund: 'refund',
    Switch: 'switch'
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action.
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch)
         * @param {string} [affiliate] Affiliate address of the action (swap)
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: (address, txid, asset, type, affiliate, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }
            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (affiliate !== undefined) {
                localVarQueryParameter['affiliate'] = affiliate;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it.
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: (address, timestamp, height, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalance', 'address', address);
            const localVarPath = `/v2/balance/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChurns: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/churns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pool' is not null or undefined
            assertParamExists('getDepthHistory', 'pool', pool);
            const localVarPath = `/v2/history/depths/{pool}`
                .replace(`{${"pool"}}`, encodeURIComponent(String(pool)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory: (interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated.
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/liquidity_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMemberDetail', 'address', address);
            const localVarPath = `/v2/member/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses: (pool, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: (asset, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPool', 'asset', asset);
            const localVarPath = `/v2/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats: (asset, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPoolStats', 'asset', asset);
            const localVarPath = `/v2/pool/{asset}/stats`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: (status, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedNodes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/swaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail: (name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getTHORNameDetail', 'name', name);
            const localVarPath = `/v2/thorname/lookup/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTHORNamesByAddress', 'address', address);
            const localVarPath = `/v2/thorname/rlookup/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames.
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesOwnerByAddress: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTHORNamesOwnerByAddress', 'address', address);
            const localVarPath = `/v2/thorname/owner/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory: (interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/tvl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action.
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch)
         * @param {string} [affiliate] Affiliate address of the action (swap)
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(address, txid, asset, type, affiliate, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActions(address, txid, asset, type, affiliate, limit, offset, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it.
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(address, timestamp, height, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalance(address, timestamp, height, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChurns(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getChurns(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDepthHistory(pool, interval, count, to, from, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEarningsHistory(interval, count, to, from, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated.
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getHealth(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLiquidityHistory(pool, interval, count, to, from, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMemberDetail(address, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMembersAdresses(pool, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNetworkData(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNodes(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPool(asset, period, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPoolStats(asset, period, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPools(status, period, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProxiedConstants(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProxiedInboundAddresses(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProxiedLastblock(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedNodes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProxiedNodes(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProxiedQueue(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStats(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSwapHistory(pool, interval, count, to, from, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTHORNameDetail(name, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTHORNamesByAddress(address, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames.
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesOwnerByAddress(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTHORNamesOwnerByAddress(address, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory(interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTVLHistory(interval, count, to, from, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DefaultApiFp(configuration);
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action.
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch)
         * @param {string} [affiliate] Affiliate address of the action (swap)
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(address, txid, asset, type, affiliate, limit, offset, options) {
            return localVarFp.getActions(address, txid, asset, type, affiliate, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it.
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(address, timestamp, height, options) {
            return localVarFp.getBalance(address, timestamp, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChurns(options) {
            return localVarFp.getChurns(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool, interval, count, to, from, options) {
            return localVarFp.getDepthHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval, count, to, from, options) {
            return localVarFp.getEarningsHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated.
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options) {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool, interval, count, to, from, options) {
            return localVarFp.getLiquidityHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address, options) {
            return localVarFp.getMemberDetail(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool, options) {
            return localVarFp.getMembersAdresses(pool, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options) {
            return localVarFp.getNetworkData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options) {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset, period, options) {
            return localVarFp.getPool(asset, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset, period, options) {
            return localVarFp.getPoolStats(asset, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status, period, options) {
            return localVarFp.getPools(status, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants(options) {
            return localVarFp.getProxiedConstants(options).then((request) => request(axios, basePath));
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses(options) {
            return localVarFp.getProxiedInboundAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock(options) {
            return localVarFp.getProxiedLastblock(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the proxied nodes endpoint from thornode
         * @summary Proxied THORChain Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedNodes(options) {
            return localVarFp.getProxiedNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the proxied queue endpoint from thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue(options) {
            return localVarFp.getProxiedQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options) {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool, interval, count, to, from, options) {
            return localVarFp.getSwapHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail(name, options) {
            return localVarFp.getTHORNameDetail(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress(address, options) {
            return localVarFp.getTHORNamesByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames.
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesOwnerByAddress(address, options) {
            return localVarFp.getTHORNamesOwnerByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory(interval, count, to, from, options) {
            return localVarFp.getTVLHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends BaseAPI {
    /**
     * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
     * @summary Actions List
     * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action.
     * @param {string} [txid] ID of any in/out tx related to the action
     * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
     * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch)
     * @param {string} [affiliate] Affiliate address of the action (swap)
     * @param {number} [limit] number of actions returned, default is 50
     * @param {number} [offset] pagination offset, default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getActions(address, txid, asset, type, affiliate, limit, offset, options) {
        return DefaultApiFp(this.configuration).getActions(address, txid, asset, type, affiliate, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it.
     * @summary Current balance for an address
     * @param {string} address Rune address.
     * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
     * @param {number} [height] Block height (if provided, timestamp must not be provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getBalance(address, timestamp, height, options) {
        return DefaultApiFp(this.configuration).getBalance(address, timestamp, height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns block height and timestamp for each churn.
     * @summary Churns List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getChurns(options) {
        return DefaultApiFp(this.configuration).getChurns(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Depth and Price History
     * @param {string} pool Return stats for this single pool.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getDepthHistory(pool, interval, count, to, from, options) {
        return DefaultApiFp(this.configuration).getDepthHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Earnings History
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getEarningsHistory(interval, count, to, from, options) {
        return DefaultApiFp(this.configuration).getEarningsHistory(interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated.
     * @summary Health Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getHealth(options) {
        return DefaultApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Liquidity Changes History
     * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400]
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getLiquidityHistory(pool, interval, count, to, from, options) {
        return DefaultApiFp(this.configuration).getLiquidityHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of statistics for all the liquidity providers associated with a given member address.
     * @summary Member Details
     * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMemberDetail(address, options) {
        return DefaultApiFp(this.configuration).getMemberDetail(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
     * @summary Members List
     * @param {string} [pool] Return only members present in the pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMembersAdresses(pool, options) {
        return DefaultApiFp(this.configuration).getMembersAdresses(pool, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing Network data
     * @summary Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getNetworkData(options) {
        return DefaultApiFp(this.configuration).getNetworkData(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of Node public keys and adresses.
     * @summary Nodes List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getNodes(options) {
        return DefaultApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details of the pool: depths, price, 24h volume, APY.
     * @summary Details of a Pool
     * @param {string} asset pool name
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPool(asset, period, options) {
        return DefaultApiFp(this.configuration).getPool(asset, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
     * @summary Pool Statistics
     * @param {string} asset pool name
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPoolStats(asset, period, options) {
        return DefaultApiFp(this.configuration).getPoolStats(asset, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array containing details for a set of pools
     * @summary Pools List
     * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPools(status, period, options) {
        return DefaultApiFp(this.configuration).getPools(status, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Constant values used by THORChain , some of the values can be overrided by mimir
     * @summary Proxied THORChain Constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedConstants(options) {
        return DefaultApiFp(this.configuration).getProxiedConstants(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
     * @summary Proxied THORChain Inbound Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedInboundAddresses(options) {
        return DefaultApiFp(this.configuration).getProxiedInboundAddresses(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve lastest block infomation across all chains.
     * @summary Proxied THORChain Lastblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedLastblock(options) {
        return DefaultApiFp(this.configuration).getProxiedLastblock(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the proxied nodes endpoint from thornode
     * @summary Proxied THORChain Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedNodes(options) {
        return DefaultApiFp(this.configuration).getProxiedNodes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the proxied queue endpoint from thornode
     * @summary Proxied THORChain Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedQueue(options) {
        return DefaultApiFp(this.configuration).getProxiedQueue(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing global stats for all pools and all transactions
     * @summary Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getStats(options) {
        return DefaultApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Swaps History
     * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getSwapHistory(pool, interval, count, to, from, options) {
        return DefaultApiFp(this.configuration).getSwapHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of chains and their addresses associated with the given THORName
     * @summary THORName Details
     * @param {string} name a THORName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTHORNameDetail(name, options) {
        return DefaultApiFp(this.configuration).getTHORNameDetail(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of THORNames associated with the given address
     * @summary Gives a list of THORNames by reverse lookup
     * @param {string} address Address to match THORNames against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTHORNamesByAddress(address, options) {
        return DefaultApiFp(this.configuration).getTHORNamesByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames.
     * @summary THORName owner
     * @param {string} address Address which owns a THORName.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTHORNamesOwnerByAddress(address, options) {
        return DefaultApiFp(this.configuration).getTHORNamesOwnerByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Total Value Locked History
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTVLHistory(interval, count, to, from, options) {
        return DefaultApiFp(this.configuration).getTVLHistory(interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SpecificationApi - axios parameter creator
 * @export
 */
const SpecificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SpecificationApi - functional programming interface
 * @export
 */
const SpecificationApiFp = function (configuration) {
    const localVarAxiosParamCreator = SpecificationApiAxiosParamCreator(configuration);
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDocs(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSwagger(options);
                return createRequestFunction(localVarAxiosArgs, globalAxios__default['default'], BASE_PATH, configuration);
            });
        },
    };
};
/**
 * SpecificationApi - factory interface
 * @export
 */
const SpecificationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SpecificationApiFp(configuration);
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options) {
            return localVarFp.getDocs(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options) {
            return localVarFp.getSwagger(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
class SpecificationApi extends BaseAPI {
    /**
     * Swagger/OpenAPI 3.0 specification generated documents.
     * @summary Documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    getDocs(options) {
        return SpecificationApiFp(this.configuration).getDocs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns human and machine readable swagger/openapi specification
     * @summary Swagger File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    getSwagger(options) {
        return SpecificationApiFp(this.configuration).getSwagger(options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifröst and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.9.4
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

const MIDGARD_API_TS_URL = 'https://midgard.thorswap.net/';
const MIDGARD_API_9R_URL = 'https://midgard.ninerealms.com/';
const MIDGARD_API_TC_URL = 'https://midgard.thorchain.info/';

exports.ActionStatusEnum = ActionStatusEnum;
exports.ActionTypeEnum = ActionTypeEnum;
exports.Configuration = Configuration;
exports.DefaultApi = DefaultApi;
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
exports.DefaultApiFactory = DefaultApiFactory;
exports.DefaultApiFp = DefaultApiFp;
exports.MIDGARD_API_9R_URL = MIDGARD_API_9R_URL;
exports.MIDGARD_API_TC_URL = MIDGARD_API_TC_URL;
exports.MIDGARD_API_TS_URL = MIDGARD_API_TS_URL;
exports.MidgardApi = DefaultApi;
exports.SpecificationApi = SpecificationApi;
exports.SpecificationApiAxiosParamCreator = SpecificationApiAxiosParamCreator;
exports.SpecificationApiFactory = SpecificationApiFactory;
exports.SpecificationApiFp = SpecificationApiFp;
