import { InboundAddress } from '@xchainjs/xchain-thornode';
import { Address, Asset, Chain } from '@xchainjs/xchain-util';
import { BigNumber } from 'bignumber.js';
import { CryptoAmount } from './crypto-amount';
import { LiquidityPool } from './liquidity-pool';
import { InboundDetail, SwapOutput } from './types';
import { Midgard } from './utils/midgard';
import { Thornode } from './utils/thornode';
/**
 * This class manages retrieving information from up to date Thorchain
 */
export declare class ThorchainCache {
    readonly midgard: Midgard;
    readonly thornode: Thornode;
    private poolCache;
    private asgardAssetsCache;
    private inboundDetailCache;
    private networkValuesCache;
    private expirePoolCacheMillis;
    private expireAsgardCacheMillis;
    private expireInboundDetailsCacheMillis;
    private expireNetworkValuesCacheMillis;
    /**
     * Contrustor to create a ThorchainCache
     *
     * @param midgard - an instance of the midgard API (could be pointing to stagenet,testnet,mainnet)
     * @param expirePoolCacheMillis - how long should the pools be cached before expiry
     * @param expireAsgardCacheMillis - how long should the inboundAsgard Addresses be cached before expiry
     * @param expireInboundDetailsCacheMillis - how long should the InboundDetails be cached before expiry
     * @param expireNetworkValuesCacheMillis - how long should the Mimir/Constants be cached before expiry
     * @returns ThorchainCache
     */
    constructor(midgard?: Midgard, thornode?: Thornode, expirePoolCacheMillis?: number, expireAsgardCacheMillis?: number, expireInboundDetailsCacheMillis?: number, expireNetworkValuesCacheMillis?: number);
    /**
     * Gets the exchange rate of the from asset in terms on the to asset
     *
     * @param asset - cannot be RUNE.
     * @returns Promise<BigNumber>
     */
    getExchangeRate(from: Asset, to: Asset): Promise<BigNumber>;
    /**
     * Gets the Liquidity Pool for a given Asset
     *
     * @param asset - cannot be RUNE, since Rune is the other side of each pool.
     * @returns Promise<LiquidityPool>
     */
    getPoolForAsset(asset: Asset): Promise<LiquidityPool>;
    /**
     * Get all the Liquidity Pools currently cached.
     * if the cache is expired, the pools wioll be re-fetched from midgard
     *
     * @returns Promise<Record<string, LiquidityPool>>
     */
    getPools(): Promise<Record<string, LiquidityPool>>;
    /**
     * Refreshes the Pool Cache
     *
     * NOTE: do not call refereshPoolCache() directly, call getPools() instead
     * which will refresh the cache if it's expired
     */
    private refereshPoolCache;
    /**
     * Refreshes the asgardAssetsCache Cache
     *
     * NOTE: do not call refereshAsgardCache() directly, call getAsgardAssets() instead
     * which will refresh the cache if it's expired
     */
    private refereshAsgardCache;
    /**
     * Refreshes the InboundDetailCache Cache
     *
     * NOTE: do not call refereshInboundDetailCache() directly, call getInboundDetails() instead
     * which will refresh the cache if it's expired
     */
    private refereshInboundDetailCache;
    /**
     * Refreshes the NetworkValuesCache Cache
     *
     * NOTE: do not call refereshNetworkValuesCache() directly, call getNetworkValuess() instead
     * which will refresh the cache if it's expired
     */
    private refereshNetworkValuesCache;
    /**
     *
     *  Calcuate the expected slip, output & swapFee given the current pool depths
     *
     *  swapFee - the amount of asset lost  according to slip calculations
     *  slip - the percent (0-1) of original amount lost to slipfees
     *  output - the amount of asset expected from the swap   *
     *
     * @param inputAmount - CryptoAmount amount to swap from
     * @param destinationAsset - destimation Asset to swap to
     * @returns SwapOutput - swap output object - output - fee - slip
     */
    getExpectedSwapOutput(inputAmount: CryptoAmount, destinationAsset: Asset): Promise<SwapOutput>;
    /**
     * Returns the exchange of a CryptoAmount to a different Asset
     *
     * Ex. convert(input:100 BUSD, outAsset: BTC) -> 0.0001234 BTC
     *
     * @param input - amount/asset to convert to outAsset
     * @param outAsset - the Asset you want to convert to
     * @returns CryptoAmount of input
     */
    convert(input: CryptoAmount, outAsset: Asset): Promise<CryptoAmount>;
    private getDecimalForAsset;
    getRouterAddressForChain(chain: Chain): Promise<Address>;
    /**
     *
     * @returns - inbound adresses item
     */
    getInboundAddresses(): Promise<Record<string, InboundAddress>>;
    /**
     *
     * @returns - inbound details
     */
    getInboundDetails(): Promise<Record<string, InboundDetail>>;
    /**
     *
     * @returns - network values
     */
    getNetworkValues(): Promise<Record<string, number>>;
    getDeepestUSDPool(): Promise<LiquidityPool>;
}
