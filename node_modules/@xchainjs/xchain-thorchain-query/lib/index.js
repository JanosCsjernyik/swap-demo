'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var xchainThornode = require('@xchainjs/xchain-thornode');
var xchainUtil = require('@xchainjs/xchain-util');
var bignumber_js = require('bignumber.js');
var xchainClient = require('@xchainjs/xchain-client');
var xchainMidgard = require('@xchainjs/xchain-midgard');
var axios = require('axios');
var axiosRetry = require('axios-retry');
var lib = require('@xchainjs/xchain-util/lib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var axiosRetry__default = /*#__PURE__*/_interopDefaultLegacy(axiosRetry);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const DefaultChainAttributes = {
    BCH: {
        blockReward: 6.25,
        avgBlockTimeInSecs: 600,
    },
    BTC: {
        blockReward: 6.25,
        avgBlockTimeInSecs: 600,
    },
    ETH: {
        blockReward: 2,
        avgBlockTimeInSecs: 13,
    },
    AVAX: {
        blockReward: 2,
        avgBlockTimeInSecs: 3,
    },
    LTC: {
        blockReward: 12.5,
        avgBlockTimeInSecs: 150,
    },
    DOGE: {
        blockReward: 10000,
        avgBlockTimeInSecs: 60,
    },
    GAIA: {
        blockReward: 0,
        avgBlockTimeInSecs: 6,
    },
    BNB: {
        blockReward: 0,
        avgBlockTimeInSecs: 6,
    },
    THOR: {
        blockReward: 0,
        avgBlockTimeInSecs: 6,
    },
};

/**
 * Utility Class to combine an amount (asset/base) with the Asset
 *
 */
class CryptoAmount {
    constructor(amount, asset) {
        this.asset = asset;
        this.baseAmount = amount;
    }
    plus(v) {
        this.check(v);
        const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.plus(v.assetAmount));
        return new CryptoAmount(assetAmountResult, this.asset);
    }
    minus(v) {
        this.check(v);
        const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.minus(v.assetAmount));
        return new CryptoAmount(assetAmountResult, this.asset);
    }
    times(v) {
        this.check(v);
        if (v instanceof CryptoAmount) {
            const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.times(v.assetAmount));
            return new CryptoAmount(assetAmountResult, this.asset);
        }
        else {
            const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.times(v));
            return new CryptoAmount(assetAmountResult, this.asset);
        }
    }
    div(v) {
        this.check(v);
        if (v instanceof CryptoAmount) {
            const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.div(v.assetAmount));
            return new CryptoAmount(assetAmountResult, this.asset);
        }
        else {
            const assetAmountResult = xchainUtil.assetToBase(this.assetAmount.div(v));
            return new CryptoAmount(assetAmountResult, this.asset);
        }
    }
    lt(v) {
        this.check(v);
        return this.assetAmount.lt(v.assetAmount);
    }
    lte(v) {
        this.check(v);
        return this.assetAmount.lte(v.assetAmount);
    }
    gt(v) {
        this.check(v);
        return this.assetAmount.gt(v.assetAmount);
    }
    gte(v) {
        this.check(v);
        return this.assetAmount.gte(v.assetAmount);
    }
    eq(v) {
        this.check(v);
        return this.assetAmount.eq(v.assetAmount);
    }
    formatedAssetString() {
        return xchainUtil.formatAssetAmountCurrency({
            amount: this.assetAmount,
            asset: this.asset,
            trimZeros: true,
        });
    }
    assetAmountFixedString() {
        return this.assetAmount.amount().toFixed();
    }
    get assetAmount() {
        return xchainUtil.baseToAsset(this.baseAmount);
    }
    /**
     * This guard protects against trying to perform math with different assets
     *
     * Example.
     * const x = new CryptoAmount(assetAmount(1),AssetBTC)
     * const y = new CryptoAmount(assetAmount(1),AssetETH)
     *
     * x.plus(y) <- will throw error "cannot perform math on 2 diff assets BTC.BTC ETH.ETH
     *
     * @param v - CryptoNumeric
     */
    check(v) {
        if (v instanceof CryptoAmount) {
            if (!xchainUtil.eqAsset(this.asset, v.asset)) {
                throw Error(`cannot perform math on 2 diff assets ${xchainUtil.assetToString(this.asset)} ${xchainUtil.assetToString(v.asset)}`);
            }
        }
    }
}

/**
 * Represent a Liquidity Pool in Thorchain
 */
class LiquidityPool {
    constructor(pool, decimals) {
        this.pool = pool;
        const asset = xchainUtil.assetFromString(this.pool.asset);
        if (!asset)
            throw new Error(`could not parse ${this.pool.asset}`);
        this.asset = asset;
        this.decimals = decimals;
        this.assetString = this.pool.asset;
        this.assetBalance = xchainUtil.baseAmount(this.pool.assetDepth);
        this.runeBalance = xchainUtil.baseAmount(this.pool.runeDepth);
        this.runeToAssetRatio = this.runeBalance.amount().div(this.assetBalance.amount());
        this.assetToRuneRatio = this.assetBalance.amount().div(this.runeBalance.amount());
    }
    isAvailable() {
        return this.pool.status.toLowerCase() === 'available';
    }
}

const defaultMidgardConfig = {
    mainnet: {
        apiRetries: 3,
        midgardBaseUrls: [
            'https://midgard.ninerealms.com',
            'https://midgard.thorchain.info',
            'https://midgard.thorswap.net',
        ],
    },
    stagenet: {
        apiRetries: 3,
        midgardBaseUrls: ['https://stagenet-midgard.ninerealms.com'],
    },
    testnet: {
        apiRetries: 3,
        midgardBaseUrls: ['https://testnet.midgard.thorchain.info'],
    },
};
class Midgard {
    constructor(network = xchainClient.Network.Mainnet, config) {
        this.network = network;
        this.config = config !== null && config !== void 0 ? config : defaultMidgardConfig[this.network];
        axiosRetry__default['default'](axios__default['default'], { retries: this.config.apiRetries, retryDelay: axiosRetry__default['default'].exponentialDelay });
        this.midgardApis = this.config.midgardBaseUrls.map((url) => new xchainMidgard.MidgardApi(new xchainMidgard.Configuration({ basePath: url })));
    }
    getMimirDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const path = '/v2/thorchain/mimir';
            for (const baseUrl of this.config.midgardBaseUrls) {
                try {
                    const { data } = yield axios__default['default'].get(`${baseUrl}${path}`);
                    return data;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error('Midgard not responding');
        });
    }
    /**
     *
     * @returns an array of Pools
     */
    getPools() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.midgardApis) {
                try {
                    return (yield api.getPools()).data;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw Error(`Midgard not responding`);
        });
    }
    /**
     *
     * @returns - constants
     */
    getConstantsDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const path = '/v2/thorchain/constants';
            for (const baseUrl of this.config.midgardBaseUrls) {
                try {
                    const { data } = yield axios__default['default'].get(`${baseUrl}${path}`);
                    return data.int_64_values;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error('Midgard not responding');
        });
    }
    /**
     *
     * @returns the outbound Tx Value in RUNE (Basemount)
     */
    getScheduledOutboundValue() {
        return __awaiter(this, void 0, void 0, function* () {
            const path = '/v2/thorchain/queue';
            for (const baseUrl of this.config.midgardBaseUrls) {
                try {
                    const { data } = yield axios__default['default'].get(`${baseUrl}${path}`);
                    const value = new CryptoAmount(xchainUtil.baseAmount(data['scheduled_outbound_value']), xchainUtil.AssetRuneNative);
                    return value;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error('Midgard not responding');
        });
    }
    /**
     * Function that wraps Mimir and Constants to return the value from a given constant name. Searchs Mimir first.
     *
     * @param networkValueName the network value to be used to search the contsants
     * @returns the mimir or constants value
     */
    getNetworkValues() {
        return __awaiter(this, void 0, void 0, function* () {
            const [mimirDetails, constantDetails] = yield Promise.all([this.getMimirDetails(), this.getConstantsDetails()]);
            const retVal = {};
            // insert constants first
            for (const constantKey of Object.keys(constantDetails)) {
                retVal[constantKey.toUpperCase()] = constantDetails[constantKey];
            }
            // mimir will overwrite any dupe constants
            for (const mimirKey of Object.keys(mimirDetails)) {
                const mimirValue = mimirDetails[mimirKey];
                retVal[mimirKey.toUpperCase()] = mimirValue;
            }
            return retVal;
        });
    }
    /**
     * Gets the latest block using the Health endpoint within Midgard
     *
     * @returns
     */
    getLatestBlockHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.midgardApis) {
                try {
                    const data = (yield api.getHealth()).data;
                    return +data.scannerHeight;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw Error(`Midgard not responding`);
        });
    }
    /**
     * Gets actions object for any of the parameters
     * @param txHash transaction id
     * @returns Type Action array of objects
     */
    getActions(address, txid, asset, type, affiliate, limit, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.midgardApis) {
                try {
                    const actions = (yield api.getActions(address, txid, asset, type, affiliate, limit, offset)).data.actions;
                    return actions;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw Error(`Midgard not responding`);
        });
    }
    /**
     * Function to return member details based on valid liquidity position
     * @param address - needed to query for Lp details
     * @returns - object type of Member Detail
     */
    getMember(address) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.midgardApis) {
                try {
                    const memberDetail = (yield api.getMemberDetail(address)).data;
                    return memberDetail;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw Error(`Midgard not responding`);
        });
    }
    /**
     * Function to return pool statistics for a particular asset
     * @param asset - asset string to query its pool stats
     * @returns - type object poolstatsDetail
     */
    getPoolStats(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.midgardApis) {
                try {
                    const poolDetail = (yield api.getPoolStats(asset)).data;
                    return poolDetail;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw Error(`Midgard not responding`);
        });
    }
}

const getBaseAmountWithDiffDecimals = (inputAmount, outDecimals) => {
    const inDecimals = inputAmount.baseAmount.decimal;
    let baseAmountOut = inputAmount.baseAmount.amount();
    const adjustDecimals = outDecimals - inDecimals;
    baseAmountOut = baseAmountOut.times(Math.pow(10, adjustDecimals));
    return xchainUtil.baseAmount(baseAmountOut, outDecimals).amount();
};
/**
 *
 * @param inputAmount - amount to swap
 * @param pool - Pool Data, RUNE and ASSET Depths
 * @param toRune - Direction of Swap. True if swapping to RUNE.
 * @returns
 */
const getSwapFee = (inputAmount, pool, toRune) => {
    // formula: (x * x * Y) / (x + X) ^ 2
    // const isInputRune = isAssetRuneNative(inputAmount.asset)
    const x = getBaseAmountWithDiffDecimals(inputAmount, 8);
    const X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    const Y = toRune ? pool.runeBalance.amount() : pool.assetBalance.amount(); // output is rune if toRune
    const units = toRune ? xchainUtil.AssetRuneNative : pool.asset;
    const numerator = x.times(x).multipliedBy(Y);
    const denominator = x.plus(X).pow(2);
    const result = numerator.div(denominator);
    const eightDecimalResult = new CryptoAmount(xchainUtil.baseAmount(result), units);
    const decimals = toRune ? 8 : inputAmount.baseAmount.decimal;
    const baseOut = getBaseAmountWithDiffDecimals(eightDecimalResult, decimals);
    const swapFee = new CryptoAmount(xchainUtil.baseAmount(baseOut, decimals), units);
    //console.log(` swapFee ${swapFee.assetAmountFixedString()} `)
    return swapFee;
};
/**
 * Works out the swap slip for a given swap.
 *
 * @param inputAmount - amount to swap
 * @param pool - Pool Data, RUNE and ASSET Depths
 * @param toRune - Direction of Swap. True if swapping to RUNE.
 * @returns The amount of slip. Needs to * 100 to get percentage.
 */
const getSwapSlip = (inputAmount, pool, toRune) => {
    // formula: (x) / (x + X)
    const x = getBaseAmountWithDiffDecimals(inputAmount, 8);
    const X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    const result = x.div(x.plus(X));
    return new bignumber_js.BigNumber(result);
};
/**
 *
 * @param inputAmount - amount to swap
 * @param pool - Pool Data, RUNE and ASSET Depths
 * @param toRune - Direction of Swap. True if swapping to RUNE.
 * @returns The output amount
 */
const getSwapOutput = (inputAmount, pool, toRune) => {
    // formula: (x * X * Y) / (x + X) ^ 2
    const x = getBaseAmountWithDiffDecimals(inputAmount, 8);
    const X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    const Y = toRune ? pool.runeBalance.amount() : pool.assetBalance.amount(); // output is rune if toRune
    const units = toRune ? xchainUtil.AssetRuneNative : pool.asset;
    // const decimals = toRune || !pool.decimals ? 8 : pool.decimals
    const numerator = x.times(X).times(Y);
    const denominator = x.plus(X).pow(2);
    const result = numerator.div(denominator);
    const eightDecimalResult = new CryptoAmount(xchainUtil.baseAmount(result), units);
    const decimals = toRune ? 8 : inputAmount.baseAmount.decimal;
    const baseOut = getBaseAmountWithDiffDecimals(eightDecimalResult, decimals);
    return new CryptoAmount(xchainUtil.baseAmount(baseOut, decimals), units);
};
const getDoubleSwapOutput = (inputAmount, pool1, pool2) => {
    // formula: getSwapOutput(pool1) => getSwapOutput(pool2)
    const r = getSwapOutput(inputAmount, pool1, true);
    const output = getSwapOutput(r, pool2, false);
    return output;
};
/**
 *
 * @param inputAmount - amount to swap
 * @param pool - Pool Data, RUNE and ASSET Depths
 * @returns swap output object - output - fee - slip
 */
const getSingleSwap = (inputAmount, pool, toRune) => {
    const output = getSwapOutput(inputAmount, pool, toRune);
    const fee = getSwapFee(inputAmount, pool, toRune);
    const slip = getSwapSlip(inputAmount, pool, toRune);
    const swapOutput = {
        output: output,
        swapFee: fee,
        slip: slip,
    };
    return swapOutput;
};
const getDoubleSwapSlip = (inputAmount, pool1, pool2) => {
    // formula: getSwapSlip1(input1) + getSwapSlip2(getSwapOutput1 => input2)
    const swapOutput1 = getSingleSwap(inputAmount, pool1, true);
    const swapOutput2 = getSingleSwap(swapOutput1.output, pool2, false);
    const result = swapOutput2.slip.plus(swapOutput1.slip);
    return result;
};
const getDoubleSwapFee = (inputAmount, pool1, pool2, thorchainCache) => __awaiter(void 0, void 0, void 0, function* () {
    // formula: getSwapFee1 + getSwapFee2
    const fee1InRune = getSwapFee(inputAmount, pool1, true);
    const swapOutput = getSwapOutput(inputAmount, pool1, true);
    const fee2InAsset = getSwapFee(swapOutput, pool2, false);
    const fee2InRune = yield thorchainCache.convert(fee2InAsset, xchainUtil.AssetRuneNative);
    const result = fee1InRune.plus(fee2InRune);
    return result;
});
/**
 *
 * @param inputAmount - amount to swap
 * @param pool - Pool Data, RUNE and ASSET Depths
 * @param toRune - Direction of Swap. True if swapping to RUNE.
 * @returns swap output object - output - fee - slip
 */
const getDoubleSwap = (inputAmount, pool1, pool2, thorchainCache) => __awaiter(void 0, void 0, void 0, function* () {
    const doubleOutput = getDoubleSwapOutput(inputAmount, pool1, pool2);
    const doubleFee = yield getDoubleSwapFee(inputAmount, pool1, pool2, thorchainCache);
    const doubleSlip = getDoubleSwapSlip(inputAmount, pool1, pool2);
    const SwapOutput = {
        output: doubleOutput,
        swapFee: doubleFee,
        slip: doubleSlip,
    };
    return SwapOutput;
});
/**
 * Works out the required inbound or outbound fee based on the chain.
 * Call getInboundDetails to get the current gasRate
 *
 * @param sourceAsset
 * @param gasRate
 * @see https://dev.thorchain.org/thorchain-dev/thorchain-and-fees#fee-calcuation-by-chain
 * @returns
 */
const calcNetworkFee = (asset, inbound) => {
    if (asset.synth)
        return new CryptoAmount(xchainUtil.baseAmount(2000000), xchainUtil.AssetRuneNative);
    switch (asset.chain) {
        case xchainUtil.Chain.Bitcoin:
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate.multipliedBy(inbound.outboundTxSize)), xchainUtil.AssetBTC);
        case xchainUtil.Chain.BitcoinCash:
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate.multipliedBy(inbound.outboundTxSize)), xchainUtil.AssetBCH);
        case xchainUtil.Chain.Litecoin:
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate.multipliedBy(inbound.outboundTxSize)), xchainUtil.AssetLTC);
        case xchainUtil.Chain.Doge:
            // NOTE: UTXO chains estimate fees with a 250 byte size
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate.multipliedBy(inbound.outboundTxSize)), xchainUtil.AssetDOGE);
        case xchainUtil.Chain.Binance:
            //flat fee
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate), xchainUtil.AssetBNB);
        case xchainUtil.Chain.Ethereum:
            const gasRateinETHGwei = inbound.gasRate;
            const gasRateinETHWei = xchainUtil.baseAmount(gasRateinETHGwei.multipliedBy(Math.pow(10, 9)), 18);
            if (xchainUtil.eqAsset(asset, xchainUtil.AssetETH)) {
                return new CryptoAmount(gasRateinETHWei.times(21000), xchainUtil.AssetETH);
            }
            else {
                return new CryptoAmount(gasRateinETHWei.times(70000), xchainUtil.AssetETH);
            }
        case xchainUtil.Chain.Avalanche:
            const gasRateinAVAXGwei = inbound.gasRate;
            const gasRateinAVAXWei = xchainUtil.baseAmount(gasRateinAVAXGwei.multipliedBy(Math.pow(10, 9)), 18);
            if (xchainUtil.eqAsset(asset, xchainUtil.AssetAVAX)) {
                return new CryptoAmount(gasRateinAVAXWei.times(21000), xchainUtil.AssetAVAX);
            }
            else {
                return new CryptoAmount(gasRateinAVAXWei.times(70000), xchainUtil.AssetAVAX);
            }
        case xchainUtil.Chain.Cosmos:
            return new CryptoAmount(xchainUtil.baseAmount(inbound.gasRate), xchainUtil.AssetAtom);
        case xchainUtil.Chain.THORChain:
            return new CryptoAmount(xchainUtil.baseAmount(2000000), xchainUtil.AssetRuneNative);
    }
    throw new Error(`could not calculate inbound fee for ${asset.chain}`);
};
/**
 * Return the chain for a given Asset This method should live somewhere else.
 * @param chain
 * @returns the gas asset type for the given chain
 */
const getChainAsset = (chain) => {
    switch (chain) {
        case xchainUtil.BNBChain:
            return xchainUtil.AssetBNB;
        case xchainUtil.BTCChain:
            return xchainUtil.AssetBTC;
        case xchainUtil.ETHChain:
            return xchainUtil.AssetETH;
        case xchainUtil.THORChain:
            return xchainUtil.AssetRuneNative;
        case xchainUtil.CosmosChain:
            return xchainUtil.AssetAtom;
        case xchainUtil.BCHChain:
            return xchainUtil.AssetBCH;
        case xchainUtil.LTCChain:
            return xchainUtil.AssetLTC;
        case xchainUtil.DOGEChain:
            return xchainUtil.AssetDOGE;
        case xchainUtil.AvalancheChain:
            return xchainUtil.AssetAVAX;
        default:
            throw Error('Unknown chain');
    }
};
/**
 *
 * @param chain - input chain string
 * @returns - returns correct chain from string
 */
const getChain = (chain) => {
    switch (chain) {
        case 'BNB':
            return xchainUtil.BNBChain;
        case 'BTC':
            return xchainUtil.BTCChain;
        case 'ETH':
            return xchainUtil.ETHChain;
        case 'THOR':
            return xchainUtil.THORChain;
        case 'GAIA':
            return xchainUtil.CosmosChain;
        case 'BCH':
            return xchainUtil.BCHChain;
        case 'LTC':
            return xchainUtil.LTCChain;
        case 'DOGE':
            return xchainUtil.DOGEChain;
        default:
            throw Error('Unknown chain');
    }
};

const defaultThornodeConfig = {
    mainnet: {
        apiRetries: 3,
        thornodeBaseUrls: [
            `https://thornode.ninerealms.com`,
            `https://thornode.thorswap.net`,
            `https://thornode.thorchain.info`,
        ],
    },
    stagenet: {
        apiRetries: 3,
        thornodeBaseUrls: ['https://stagenet-thornode.ninerealms.com'],
    },
    testnet: {
        apiRetries: 3,
        thornodeBaseUrls: ['https://testnet.thornode.thorchain.info'],
    },
};
class Thornode {
    constructor(network = xchainClient.Network.Mainnet, config) {
        this.network = network;
        this.config = config !== null && config !== void 0 ? config : defaultThornodeConfig[this.network];
        axiosRetry__default['default'](axios__default['default'], { retries: this.config.apiRetries, retryDelay: axiosRetry__default['default'].exponentialDelay });
        this.transactionsApi = this.config.thornodeBaseUrls.map((url) => new xchainThornode.TransactionsApi(new xchainThornode.Configuration({ basePath: url })));
        this.queueApi = this.config.thornodeBaseUrls.map((url) => new xchainThornode.QueueApi(new xchainThornode.Configuration({ basePath: url })));
        this.networkApi = this.config.thornodeBaseUrls.map((url) => new xchainThornode.NetworkApi(new xchainThornode.Configuration({ basePath: url })));
        this.poolsApi = this.config.thornodeBaseUrls.map((url) => new xchainThornode.PoolsApi(new xchainThornode.Configuration({ basePath: url })));
        this.liquidityProvidersApi = this.config.thornodeBaseUrls.map((url) => new xchainThornode.LiquidityProvidersApi(new xchainThornode.Configuration({ basePath: url })));
    }
    /**
     * Returns the oubound transactions held by THORChain due to outbound delay
     * May be empty if there are no transactions
     *
     * @returns {ScheduledQueueItem} Array
     *
     */
    getscheduledQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.queueApi) {
                try {
                    const queueScheduled = yield api.queueScheduled();
                    return queueScheduled.data;
                }
                catch (e) {
                    console.error(e);
                    throw new Error(`THORNode not responding`);
                }
            }
            throw Error(`THORNode not responding`);
        });
    }
    /**
     *
     * @param txHash - transaction hash
     * @returns - transaction object
     */
    getTxData(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.transactionsApi) {
                try {
                    const txResponse = yield api.tx(txHash);
                    return txResponse.data;
                }
                catch (e) {
                    const txR = {
                        observed_tx: undefined,
                        keysign_metric: undefined,
                    };
                    return txR;
                }
            }
            throw new Error(`THORNode not responding`);
        });
    }
    /**
     *
     * @param height - optional thorchain height only
     * @returns - last block data || or block data pertaining to that height number
     */
    getLastBlock(height) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.networkApi) {
                try {
                    const lastBlock = yield api.lastblock(height);
                    return lastBlock.data;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error(`THORNode not responding`);
        });
    }
    /**
     *
     * @returns - thorchain pool
     */
    getPools() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.poolsApi) {
                try {
                    // console.log(console.log(JSON.stringify(api, null, 2)))
                    const pools = yield api.pools();
                    return pools.data;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error(`THORNode not responding`);
        });
    }
    /**
     *
     * @param asset - asset string
     * @param address - address
     * @param height - optional block height, defaults to current tip
     * @returns
     */
    getLiquidityProvider(asset, address, height) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.liquidityProvidersApi) {
                try {
                    const lps = (yield api.liquidityProviders(asset, height)).data;
                    return lps.find((lp) => lp.asset_address === address || lp.rune_address === address);
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error(`THORNode not responding`);
        });
    }
    /**
     *
     * @param asset - asset string
     * @param address - address
     * @param height - optional block height, defaults to current tip
     * @returns
     */
    getInboundAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const api of this.networkApi) {
                try {
                    const resp = (yield api.inboundAddresses()).data;
                    return resp;
                }
                catch (e) {
                    console.error(e);
                }
            }
            throw new Error(`THORNode not responding`);
        });
    }
}

const SAME_ASSET_EXCHANGE_RATE = new bignumber_js.BigNumber(1);
const TEN_MINUTES = 10 * 60 * 1000;
const DEFAULT_THORCHAIN_DECIMALS = 8;
const USD_ASSETS = {
    mainnet: [
        xchainUtil.assetFromStringEx('BNB.BUSD-BD1'),
        xchainUtil.assetFromStringEx('ETH.USDC-0XA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48'),
        xchainUtil.assetFromStringEx('ETH.USDT-0XDAC17F958D2EE523A2206206994597C13D831EC7'),
    ],
    stagenet: [xchainUtil.assetFromStringEx('ETH.USDT-0XDAC17F958D2EE523A2206206994597C13D831EC7')],
    testnet: [
        xchainUtil.assetFromStringEx('BNB.BUSD-74E'),
        xchainUtil.assetFromStringEx('ETH.USDT-0XA3910454BF2CB59B8B3A401589A3BACC5CA42306'),
    ],
};
const defaultMidgard = new Midgard();
const defaultThornode = new Thornode();
/**
 * This class manages retrieving information from up to date Thorchain
 */
class ThorchainCache {
    /**
     * Contrustor to create a ThorchainCache
     *
     * @param midgard - an instance of the midgard API (could be pointing to stagenet,testnet,mainnet)
     * @param expirePoolCacheMillis - how long should the pools be cached before expiry
     * @param expireAsgardCacheMillis - how long should the inboundAsgard Addresses be cached before expiry
     * @param expireInboundDetailsCacheMillis - how long should the InboundDetails be cached before expiry
     * @param expireNetworkValuesCacheMillis - how long should the Mimir/Constants be cached before expiry
     * @returns ThorchainCache
     */
    constructor(midgard = defaultMidgard, thornode = defaultThornode, expirePoolCacheMillis = 6000, expireAsgardCacheMillis = TEN_MINUTES, expireInboundDetailsCacheMillis = 6000, expireNetworkValuesCacheMillis = TEN_MINUTES) {
        this.asgardAssetsCache = undefined;
        this.inboundDetailCache = undefined;
        this.networkValuesCache = undefined;
        this.midgard = midgard;
        this.thornode = thornode;
        this.expirePoolCacheMillis = expirePoolCacheMillis;
        this.expireAsgardCacheMillis = expireAsgardCacheMillis;
        this.expireInboundDetailsCacheMillis = expireInboundDetailsCacheMillis;
        this.expireNetworkValuesCacheMillis = expireNetworkValuesCacheMillis;
        //initialize the cache
        this.refereshPoolCache();
    }
    /**
     * Gets the exchange rate of the from asset in terms on the to asset
     *
     * @param asset - cannot be RUNE.
     * @returns Promise<BigNumber>
     */
    getExchangeRate(from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            let exchangeRate;
            if (xchainUtil.eqAsset(from, to)) {
                exchangeRate = SAME_ASSET_EXCHANGE_RATE;
            }
            else if (xchainUtil.isAssetRuneNative(from)) {
                //  Runes per Asset
                const lpTo = yield this.getPoolForAsset(to);
                exchangeRate = lpTo.assetToRuneRatio;
            }
            else if (xchainUtil.isAssetRuneNative(to)) {
                //  Asset per rune
                const lpFrom = yield this.getPoolForAsset(from);
                exchangeRate = lpFrom.runeToAssetRatio;
            }
            else {
                //  AssetA per AssetB
                const lpFrom = yield this.getPoolForAsset(from);
                const lpTo = yield this.getPoolForAsset(to);
                // from/R * R/to = from/to
                exchangeRate = lpFrom.runeToAssetRatio.times(lpTo.assetToRuneRatio);
            }
            // console.log(` 1 ${assetToString(from)} = ${exchangeRate} ${assetToString(to)}`)
            return exchangeRate;
        });
    }
    /**
     * Gets the Liquidity Pool for a given Asset
     *
     * @param asset - cannot be RUNE, since Rune is the other side of each pool.
     * @returns Promise<LiquidityPool>
     */
    getPoolForAsset(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (xchainUtil.isAssetRuneNative(asset))
                throw Error(`AssetRuneNative doesn't have a pool`);
            const pools = yield this.getPools();
            // Not: we use ticker, not asset string to get the same pool for both assets and synths
            const pool = pools[asset.ticker];
            if (pool) {
                return pool;
            }
            throw Error(`Pool for ${xchainUtil.assetToString(asset)} not found`);
        });
    }
    /**
     * Get all the Liquidity Pools currently cached.
     * if the cache is expired, the pools wioll be re-fetched from midgard
     *
     * @returns Promise<Record<string, LiquidityPool>>
     */
    getPools() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const millisSinceLastRefeshed = Date.now() - (((_a = this.poolCache) === null || _a === void 0 ? void 0 : _a.lastRefreshed) || 0);
            if (millisSinceLastRefeshed > this.expirePoolCacheMillis) {
                try {
                    yield this.refereshPoolCache();
                }
                catch (e) {
                    console.error(e);
                }
            }
            if (this.poolCache) {
                return (_b = this.poolCache) === null || _b === void 0 ? void 0 : _b.pools;
            }
            else {
                throw Error(`Could not refresh Pools `);
            }
        });
    }
    /**
     * Refreshes the Pool Cache
     *
     * NOTE: do not call refereshPoolCache() directly, call getPools() instead
     * which will refresh the cache if it's expired
     */
    refereshPoolCache() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [thornodePools, midgardPools] = yield Promise.all([this.thornode.getPools(), this.midgard.getPools()]);
            const poolMap = {};
            if (midgardPools) {
                for (const pool of midgardPools) {
                    const thornodePool = thornodePools.find((p) => p.asset === pool.asset);
                    const decimals = (_a = thornodePool === null || thornodePool === void 0 ? void 0 : thornodePool.decimals) !== null && _a !== void 0 ? _a : 8;
                    const lp = new LiquidityPool(pool, decimals);
                    poolMap[lp.asset.ticker] = lp;
                }
                this.poolCache = {
                    lastRefreshed: Date.now(),
                    pools: poolMap,
                };
            }
        });
    }
    /**
     * Refreshes the asgardAssetsCache Cache
     *
     * NOTE: do not call refereshAsgardCache() directly, call getAsgardAssets() instead
     * which will refresh the cache if it's expired
     */
    refereshAsgardCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const inboundAddresses = yield this.thornode.getInboundAddresses();
            const map = {};
            if (inboundAddresses) {
                for (const inboundAddress of inboundAddresses) {
                    if (!inboundAddress.chain)
                        throw Error('chain needed');
                    map[inboundAddress.chain] = inboundAddress;
                }
                this.asgardAssetsCache = {
                    lastRefreshed: Date.now(),
                    inboundAddresses: map,
                };
            }
        });
    }
    /**
     * Refreshes the InboundDetailCache Cache
     *
     * NOTE: do not call refereshInboundDetailCache() directly, call getInboundDetails() instead
     * which will refresh the cache if it's expired
     */
    refereshInboundDetailCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const [mimirDetails, allInboundAddresses] = yield Promise.all([
                this.midgard.getMimirDetails(),
                this.thornode.getInboundAddresses(),
            ]);
            const inboundDetails = {};
            for (const inbound of allInboundAddresses) {
                const chain = inbound.chain;
                if (!chain ||
                    !inbound.gas_rate ||
                    !inbound.address ||
                    !inbound.gas_rate_units ||
                    !inbound.outbound_tx_size ||
                    !inbound.outbound_fee ||
                    !inbound.gas_rate_units)
                    throw new Error(`Missing required inbound info`);
                const details = {
                    chain: chain,
                    address: inbound.address,
                    router: inbound.router,
                    gasRate: new bignumber_js.BigNumber(inbound.gas_rate),
                    gasRateUnits: inbound.gas_rate_units,
                    outboundTxSize: new bignumber_js.BigNumber(inbound.outbound_tx_size),
                    outboundFee: new bignumber_js.BigNumber(inbound.outbound_fee),
                    haltedChain: (inbound === null || inbound === void 0 ? void 0 : inbound.halted) || !!mimirDetails[`HALT${chain}CHAIN`] || !!mimirDetails['HALTCHAINGLOBAL'],
                    haltedTrading: !!mimirDetails['HALTTRADING'] || !!mimirDetails[`HALT${chain}TRADING`],
                    haltedLP: !!mimirDetails['PAUSELP'] || !!mimirDetails[`PAUSELP${chain}`],
                };
                inboundDetails[chain] = details;
            }
            // add mock THORCHAIN inbound details
            const details = {
                chain: xchainUtil.Chain.THORChain,
                address: '',
                router: '',
                gasRate: new bignumber_js.BigNumber(0),
                gasRateUnits: '',
                outboundTxSize: new bignumber_js.BigNumber(0),
                outboundFee: new bignumber_js.BigNumber(0),
                haltedChain: false,
                haltedTrading: !!mimirDetails['HALTTRADING'],
                haltedLP: false, //
            };
            inboundDetails[xchainUtil.Chain.THORChain] = details;
            this.inboundDetailCache = {
                lastRefreshed: Date.now(),
                inboundDetails,
            };
        });
    }
    /**
     * Refreshes the NetworkValuesCache Cache
     *
     * NOTE: do not call refereshNetworkValuesCache() directly, call getNetworkValuess() instead
     * which will refresh the cache if it's expired
     */
    refereshNetworkValuesCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const networkValues = yield this.midgard.getNetworkValues();
            this.networkValuesCache = {
                lastRefreshed: Date.now(),
                networkValues,
            };
        });
    }
    /**
     *
     *  Calcuate the expected slip, output & swapFee given the current pool depths
     *
     *  swapFee - the amount of asset lost  according to slip calculations
     *  slip - the percent (0-1) of original amount lost to slipfees
     *  output - the amount of asset expected from the swap   *
     *
     * @param inputAmount - CryptoAmount amount to swap from
     * @param destinationAsset - destimation Asset to swap to
     * @returns SwapOutput - swap output object - output - fee - slip
     */
    getExpectedSwapOutput(inputAmount, destinationAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (xchainUtil.isAssetRuneNative(inputAmount.asset)) {
                //singleswap from rune -> asset
                const pool = yield this.getPoolForAsset(destinationAsset);
                return getSingleSwap(inputAmount, pool, false);
            }
            else if (xchainUtil.isAssetRuneNative(destinationAsset)) {
                //singleswap from  asset -> rune
                const pool = yield this.getPoolForAsset(inputAmount.asset);
                return getSingleSwap(inputAmount, pool, true);
            }
            else {
                //doubleswap asset-> asset
                const inPool = yield this.getPoolForAsset(inputAmount.asset);
                const destPool = yield this.getPoolForAsset(destinationAsset);
                return yield getDoubleSwap(inputAmount, inPool, destPool, this);
            }
        });
    }
    /**
     * Returns the exchange of a CryptoAmount to a different Asset
     *
     * Ex. convert(input:100 BUSD, outAsset: BTC) -> 0.0001234 BTC
     *
     * @param input - amount/asset to convert to outAsset
     * @param outAsset - the Asset you want to convert to
     * @returns CryptoAmount of input
     */
    convert(input, outAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            const exchangeRate = yield this.getExchangeRate(input.asset, outAsset);
            const outDecimals = yield this.getDecimalForAsset(outAsset);
            const inDecimals = input.baseAmount.decimal;
            let baseAmountOut = input.baseAmount.times(exchangeRate).amount();
            const adjustDecimals = outDecimals - inDecimals;
            baseAmountOut = baseAmountOut.times(Math.pow(10, adjustDecimals));
            const amt = xchainUtil.baseAmount(baseAmountOut, outDecimals);
            const result = new CryptoAmount(amt, outAsset);
            // console.log(
            //   `${input.formatedAssetString()} ${input.asset.ticker} = ${result.formatedAssetString()} ${outAsset.ticker}`,
            // )
            return result;
        });
    }
    getDecimalForAsset(asset) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!xchainUtil.isAssetRuneNative(asset)) {
                const pool = yield this.getPoolForAsset(asset);
                return (_a = pool.decimals) !== null && _a !== void 0 ? _a : DEFAULT_THORCHAIN_DECIMALS;
            }
            return DEFAULT_THORCHAIN_DECIMALS;
        });
    }
    getRouterAddressForChain(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const inboundAsgard = (yield this.getInboundAddresses())[chain];
            if (!(inboundAsgard === null || inboundAsgard === void 0 ? void 0 : inboundAsgard.router)) {
                throw new Error('router address is not defined');
            }
            return inboundAsgard === null || inboundAsgard === void 0 ? void 0 : inboundAsgard.router;
        });
    }
    /**
     *
     * @returns - inbound adresses item
     */
    getInboundAddresses() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const millisSinceLastRefeshed = Date.now() - (((_a = this.asgardAssetsCache) === null || _a === void 0 ? void 0 : _a.lastRefreshed) || 0);
            if (millisSinceLastRefeshed > this.expireAsgardCacheMillis) {
                try {
                    yield this.refereshAsgardCache();
                }
                catch (e) {
                    console.error(e);
                }
            }
            if (this.asgardAssetsCache) {
                return this.asgardAssetsCache.inboundAddresses;
            }
            else {
                throw Error(`Could not refresh refereshAsgardCache `);
            }
        });
    }
    /**
     *
     * @returns - inbound details
     */
    getInboundDetails() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const millisSinceLastRefeshed = Date.now() - (((_a = this.inboundDetailCache) === null || _a === void 0 ? void 0 : _a.lastRefreshed) || 0);
            if (millisSinceLastRefeshed > this.expireInboundDetailsCacheMillis) {
                try {
                    yield this.refereshInboundDetailCache();
                }
                catch (e) {
                    console.error(e);
                }
            }
            if (this.inboundDetailCache) {
                return this.inboundDetailCache.inboundDetails;
            }
            else {
                throw Error(`Could not refereshInboundDetailCache `);
            }
        });
    }
    /**
     *
     * @returns - network values
     */
    getNetworkValues() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const millisSinceLastRefeshed = Date.now() - (((_a = this.networkValuesCache) === null || _a === void 0 ? void 0 : _a.lastRefreshed) || 0);
            if (millisSinceLastRefeshed > this.expireNetworkValuesCacheMillis) {
                try {
                    yield this.refereshNetworkValuesCache();
                }
                catch (e) {
                    console.error(e);
                }
            }
            if (this.networkValuesCache) {
                return this.networkValuesCache.networkValues;
            }
            else {
                throw Error(`Could not refereshInboundDetailCache `);
            }
        });
    }
    getDeepestUSDPool() {
        return __awaiter(this, void 0, void 0, function* () {
            const usdAssets = USD_ASSETS[this.midgard.network];
            let deepestRuneDepth = new bignumber_js.BigNumber(0);
            let deepestPool = null;
            for (const usdAsset of usdAssets) {
                const usdPool = yield this.getPoolForAsset(usdAsset);
                if (usdPool.runeBalance.amount() > deepestRuneDepth) {
                    deepestRuneDepth = usdPool.runeBalance.amount();
                    deepestPool = usdPool;
                }
            }
            if (!deepestPool)
                throw Error('now USD Pool found');
            return deepestPool;
        });
    }
}

(function (TxStage) {
    TxStage[TxStage["INBOUND_CHAIN_UNCONFIRMED"] = 0] = "INBOUND_CHAIN_UNCONFIRMED";
    TxStage[TxStage["CONF_COUNTING"] = 1] = "CONF_COUNTING";
    TxStage[TxStage["TC_PROCESSING"] = 2] = "TC_PROCESSING";
    TxStage[TxStage["OUTBOUND_QUEUED"] = 3] = "OUTBOUND_QUEUED";
    TxStage[TxStage["OUTBOUND_CHAIN_UNCONFIRMED"] = 4] = "OUTBOUND_CHAIN_UNCONFIRMED";
    TxStage[TxStage["OUTBOUND_CHAIN_CONFIRMED"] = 5] = "OUTBOUND_CHAIN_CONFIRMED";
})(exports.TxStage || (exports.TxStage = {}));

/**
 * https://dev.thorchain.org/thorchain-dev/interface-guide/math#lp-units-add
 * @param liquidity - asset amount added
 * @param pool  - pool depths
 * @returns liquidity units - ownership of pool
 */
const getLiquidityUnits = (liquidity, pool) => {
    const baseAmount8decimals = getBaseAmountWithDiffDecimals(liquidity.asset, 8);
    const P = new bignumber_js.BigNumber(pool.pool.liquidityUnits);
    const r = liquidity.rune.baseAmount.amount();
    const a = baseAmount8decimals;
    const R = pool.runeBalance.amount();
    const A = pool.assetBalance.amount();
    const part1 = R.times(a);
    const part2 = r.times(A);
    const numerator = P.times(part1.plus(part2));
    const denominator = R.times(A).times(2);
    const result = numerator.div(denominator);
    return result;
};
/**
 *
 * @param unitData - units for both asset and rune
 * @param pool - pool that the asset is bound to
 * @returns - pool share of both asset and rune in percentage
 */
const getPoolShare = (unitData, pool) => {
    // formula: (rune * part) / total; (asset * part) / total
    const units = unitData.liquidityUnits;
    const total = unitData.totalUnits;
    const R = pool.runeBalance.amount();
    const T = pool.assetBalance.amount();
    const asset = T.times(units).div(total);
    const rune = R.times(units).div(total);
    const poolShareDetail = {
        assetShare: new CryptoAmount(lib.baseAmount(asset), pool.asset),
        runeShare: new CryptoAmount(lib.baseAmount(rune), lib.AssetRuneNative),
    };
    return poolShareDetail;
};
/**
 *
 * @param poolShare - the share of asset and rune added to the pool
 * @param pool - Pool that the asset is attached to
 * @returns - returns bignumber representing a slip percentage
 */
const getSlipOnLiquidity = (stake, pool) => {
    const baseAmount8decimals = getBaseAmountWithDiffDecimals(stake.asset, pool.decimals);
    // formula: (t * R - T * r)/ (T*r + R*T)
    const r = stake.rune.baseAmount.amount();
    const t = baseAmount8decimals;
    const R = pool.runeBalance.amount();
    const T = pool.assetBalance.amount();
    const numerator = t.times(R).minus(T.times(r));
    const denominator = T.times(r).plus(R.times(T));
    const result = numerator.div(denominator).abs();
    return result;
};
/**
 * https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools#impermanent-loss-protection
 * @param poolShare - the share of asset and rune added to the pool
 * @param pool - Pool that the asset is attached to
 * @param block - blockl object with current, last added and the constant blocksforlossProtection
 * @returns
 */
// Blocks for full protection 1440000 // 100 days
const getLiquidityProtectionData = (depositValue, poolShare, block) => {
    //Coverage formula coverage=((A0P1)+R0)((A1P1)+R1)=>((A0R1/A1)+R0)(R1+R1)
    //formula: protectionProgress (currentHeight-heightLastAdded)/blocksforfullprotection
    const R0 = depositValue.rune.amount(); // rune deposit value
    const A0 = depositValue.asset.amount(); // asset deposit value
    const R1 = poolShare.runeShare.baseAmount.amount(); // rune amount to redeem
    const A1 = poolShare.assetShare.baseAmount.amount(); // asset amount to redeem
    const P1 = R1.div(A1); // Pool ratio at withdrawal
    const part1 = A0.times(P1).plus(R0).minus(A1.times(P1).plus(R1)); // start position minus end position
    const part2 = A0.times(R1.div(A1)).plus(R0).minus(R1.plus(R1)); // different way to check position
    const coverage = part1 >= part2 ? part1 : part2; // Coverage represents how much ILP a LP is entitled to
    const currentHeight = block.current;
    const heightLastAdded = block.lastAdded || 0; //default to zero if undefined
    const blocksforfullprotection = block.fullProtection;
    const protectionProgress = (currentHeight - heightLastAdded) / blocksforfullprotection; // percentage of entitlement
    const result = coverage.times(protectionProgress); // impermanent loss protection result
    const ILProtection = {
        ILProtection: new CryptoAmount(lib.baseAmount(result), lib.AssetRuneNative),
        totalDays: (protectionProgress * 100).toFixed(2),
    };
    return ILProtection;
};

const BN_1 = new bignumber_js.BigNumber(1);
const defaultCache = new ThorchainCache();
/**
 * THORChain Class for interacting with THORChain.
 * Recommended main class to use for swapping with THORChain
 * Has access to Midgard and THORNode data
 */
class ThorchainQuery {
    /**
     * Contructor to create a ThorchainAMM
     *
     * @param thorchainCache - an instance of the ThorchainCache (could be pointing to stagenet,testnet,mainnet)
     * @param chainAttributes - atrributes used to calculate waitTime & conf counting
     * @returns ThorchainAMM
     */
    constructor(thorchainCache = defaultCache, chainAttributes = DefaultChainAttributes) {
        this.thorchainCache = thorchainCache;
        this.chainAttributes = chainAttributes;
    }
    /**
     * Provides a swap estimate for the given swap detail. Will check the params for errors before trying to get the estimate.
     * Uses current pool data, works out inbound and outboud fee, affiliate fees and works out the expected wait time for the swap (in and out)
     *
     * @param params - amount to swap
  
     * @returns The SwapEstimate
     */
    estimateSwap({ input, destinationAsset, destinationAddress, affiliateAddress = '', interfaceID = 999, affiliateFeePercent = 0, slipLimit, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isValidSwap({
                input,
                destinationAsset,
                destinationAddress,
                affiliateAddress,
                interfaceID,
                affiliateFeePercent,
                slipLimit,
            });
            const inboundDetails = yield this.thorchainCache.getInboundDetails();
            const sourceInboundDetails = inboundDetails[input.asset.chain];
            const destinationInboundDetails = inboundDetails[destinationAsset.chain];
            const swapEstimate = yield this.calcSwapEstimate({
                input,
                destinationAsset,
                destinationAddress,
                affiliateAddress,
                interfaceID,
                affiliateFeePercent,
                slipLimit,
            }, sourceInboundDetails, destinationInboundDetails);
            // Remove any affiliateFee. netInput * affiliateFee (%age) of the destination asset type
            const affiliateFee = input.baseAmount.times(affiliateFeePercent || 0);
            // Calculate expiry time
            const currentDatetime = new Date();
            const minutesToAdd = 15;
            const expiryDatetime = new Date(currentDatetime.getTime() + minutesToAdd * 60000);
            // Check for errors
            const errors = yield this.getSwapEstimateErrors({
                input,
                destinationAsset,
                destinationAddress,
                affiliateAddress,
                interfaceID,
                affiliateFeePercent,
                slipLimit,
            }, swapEstimate, sourceInboundDetails, destinationInboundDetails);
            const txDetails = {
                memo: '',
                toAddress: '',
                expiry: expiryDatetime,
                txEstimate: swapEstimate,
            };
            if (errors.length > 0) {
                txDetails.txEstimate.canSwap = false;
                txDetails.txEstimate.errors = errors;
            }
            else {
                txDetails.txEstimate.canSwap = true;
                // Retrieve inbound Asgard address.
                const inboundAsgard = (yield this.thorchainCache.getInboundAddresses())[input.asset.chain];
                txDetails.toAddress = (inboundAsgard === null || inboundAsgard === void 0 ? void 0 : inboundAsgard.address) || '';
                // Work out LIM from the slip percentage
                let limPercentage = BN_1;
                if (slipLimit) {
                    limPercentage = BN_1.minus(slipLimit || 1);
                } // else allowed slip is 100%
                const limAssetAmount = swapEstimate.netOutput.times(limPercentage);
                const inboundDelay = yield this.confCounting(input);
                const outboundDelay = yield this.outboundDelay(limAssetAmount);
                txDetails.txEstimate.waitTimeSeconds = outboundDelay + inboundDelay;
                // Construct memo
                txDetails.memo = this.constructSwapMemo({
                    input: input,
                    destinationAsset: destinationAsset,
                    limit: limAssetAmount.baseAmount,
                    destinationAddress: destinationAddress,
                    affiliateAddress: affiliateAddress,
                    affiliateFee,
                    interfaceID: interfaceID,
                });
            }
            return txDetails;
        });
    }
    /**
     * Basic Checks for swap information
     * @param params
     */
    isValidSwap(params) {
        // TODO validate all input fields
        if (xchainUtil.eqAsset(params.input.asset, params.destinationAsset))
            throw Error(`sourceAsset and destinationAsset cannot be the same`);
        if (params.input.baseAmount.lte(0))
            throw Error('inputAmount must be greater than 0');
        if (params.affiliateFeePercent && (params.affiliateFeePercent < 0 || params.affiliateFeePercent > 0.1))
            throw Error(`affiliateFee must be between 0 and 1000`);
    }
    /**
     * Does the calculations for the swap.
     * Used by estimateSwap
     *
     * @param params
     * @param sourceInboundDetails
     * @param destinationInboundDetails
     * @param sourcePool
     * @param destinationPool
     * @returns
     */
    calcSwapEstimate(params, sourceInboundDetails, destinationInboundDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            // NOTE need to convert the asset to 8 decimals places for all calcs
            const DEFAULT_THORCHAIN_DECIMALS = 8;
            // If input is already in 8 decimals skip the convert
            const input = params.input.baseAmount.decimal === DEFAULT_THORCHAIN_DECIMALS
                ? params.input
                : yield this.thorchainCache.convert(params.input, params.input.asset);
            // If asset is already rune native, skip the convert
            const inputInRune = input.asset === xchainUtil.AssetRuneNative ? input : yield this.thorchainCache.convert(input, xchainUtil.AssetRuneNative);
            const inboundFeeInAsset = calcNetworkFee(input.asset, sourceInboundDetails);
            // Retrieve outbound fee from inboundAddressDetails.
            const outboundFeeInAsset = new CryptoAmount(xchainUtil.baseAmount(destinationInboundDetails.outboundFee), params.destinationAsset);
            // convert fees to rune
            const inboundFeeInRune = yield this.thorchainCache.convert(inboundFeeInAsset, xchainUtil.AssetRuneNative);
            let outboundFeeInRune = yield this.thorchainCache.convert(outboundFeeInAsset, xchainUtil.AssetRuneNative);
            // ---------- Remove Fees from inbound before doing the swap -----------
            // TODO confirm with chris about this change, was there a reason why this was commented out?
            const inputMinusInboundFeeInRune = inputInRune.minus(inboundFeeInRune);
            //>//const inputMinusInboundFeeInRune = inputInRune
            // remove any affiliateFee. netInput * affiliateFee (%age) of the destination asset type
            const affiliateFeeInRune = inputMinusInboundFeeInRune.times(params.affiliateFeePercent || 0);
            // remove the affiliate fee from the input.
            const inputNetAmountInRune = inputMinusInboundFeeInRune.minus(affiliateFeeInRune);
            // convert back to input asset
            const inputNetInAsset = yield this.thorchainCache.convert(inputNetAmountInRune, input.asset);
            // Check outbound fee is equal too or greater than 1 USD * need to find a more permanent solution to this. referencing just 1 stable coin pool has problems
            if (params.destinationAsset.chain !== xchainUtil.Chain.THORChain && !params.destinationAsset.synth) {
                const deepestUSDPOOL = yield this.thorchainCache.getDeepestUSDPool();
                const usdAsset = deepestUSDPOOL.asset;
                const networkValues = yield this.thorchainCache.midgard.getNetworkValues();
                const usdMinFee = new CryptoAmount(xchainUtil.baseAmount(networkValues['MINIMUML1OUTBOUNDFEEUSD']), usdAsset);
                // const FeeInUSD = await this.convert(outboundFeeInRune, usdAsset)
                const checkOutboundFee = (yield this.convert(outboundFeeInRune, usdAsset)).gte(usdMinFee);
                if (!checkOutboundFee) {
                    const newFee = usdMinFee;
                    outboundFeeInRune = yield this.convert(newFee, xchainUtil.AssetRuneNative);
                }
            }
            // Now calculate swap output based on inputNetAmount
            const swapOutput = yield this.thorchainCache.getExpectedSwapOutput(inputNetInAsset, params.destinationAsset);
            const swapFeeInRune = yield this.thorchainCache.convert(swapOutput.swapFee, xchainUtil.AssetRuneNative);
            const outputInRune = yield this.thorchainCache.convert(swapOutput.output, xchainUtil.AssetRuneNative);
            // ---------------- Remove Outbound Fee ---------------------- /
            const netOutputInRune = outputInRune.minus(outboundFeeInRune);
            const netOutputInAsset = yield this.thorchainCache.convert(netOutputInRune, params.destinationAsset);
            const totalFees = {
                inboundFee: inboundFeeInRune,
                swapFee: swapFeeInRune,
                outboundFee: outboundFeeInRune,
                affiliateFee: affiliateFeeInRune,
            };
            const swapEstimate = {
                totalFees: totalFees,
                slipPercentage: swapOutput.slip,
                netOutput: netOutputInAsset,
                waitTimeSeconds: 0,
                canSwap: false,
                errors: [],
            };
            return swapEstimate;
        });
    }
    /**
     *
     * @param params - swap object
     * @returns - constructed memo string
     */
    constructSwapMemo(params) {
        const limstring = params.limit.amount().toFixed();
        // create LIM with interface ID
        const lim = limstring.substring(0, limstring.length - 3).concat(params.interfaceID.toString());
        // create the full memo
        let memo = `=:${xchainUtil.assetToString(params.destinationAsset)}`;
        if (params.affiliateAddress != '' || params.affiliateFee == undefined) {
            memo = memo.concat(`:${params.destinationAddress}:${lim}:${params.affiliateAddress}:${params.affiliateFee.amount().toFixed()}`);
        }
        else {
            memo = memo.concat(`:${params.destinationAddress}:${lim}`);
        }
        // If memo length is too long for BTC, trim it
        if (xchainUtil.eqAsset(params.input.asset, xchainUtil.AssetBTC) && memo.length > 80) {
            memo = `=:${xchainUtil.assetToString(params.destinationAsset)}:${params.destinationAddress}`;
        }
        return memo;
    }
    /**
     * Looks for errors or issues within swap prams before doing the swap.
     *
     *
     * @param params
     * @param estimate
     * @param sourcePool
     * @param sourceInboundDetails
     * @param destinationPool
     * @param destinationInboundDetails
     * @returns
     */
    getSwapEstimateErrors(params, estimate, sourceInboundDetails, destinationInboundDetails) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const errors = [];
            const sourceAsset = params.input.asset;
            const destAsset = params.destinationAsset;
            if (!xchainUtil.isAssetRuneNative(sourceAsset)) {
                const sourcePool = yield this.thorchainCache.getPoolForAsset(sourceAsset);
                if (!sourcePool.isAvailable())
                    errors.push(`sourceAsset ${sourceAsset.ticker} does not have a valid liquidity pool`);
            }
            if (!xchainUtil.isAssetRuneNative(destAsset)) {
                const destPool = yield this.thorchainCache.getPoolForAsset(destAsset);
                if (!destPool.isAvailable())
                    errors.push(`destinationAsset ${destAsset.ticker} does not have a valid liquidity pool`);
            }
            if (sourceInboundDetails.haltedChain)
                errors.push(`source chain is halted`);
            if (sourceInboundDetails.haltedTrading)
                errors.push(`source pool is halted trading`);
            if (destinationInboundDetails.haltedChain)
                errors.push(`destination chain is halted`);
            if (destinationInboundDetails.haltedTrading)
                errors.push(`destination pool is halted trading`);
            if (estimate.slipPercentage.gte(params.slipLimit || 1))
                errors.push(`expected slip: ${estimate.slipPercentage.toFixed()} is greater than your slip limit:${(_a = params.slipLimit) === null || _a === void 0 ? void 0 : _a.toFixed()} `);
            // only proceed to check fees if there are no errors so far
            if (errors.length > 0)
                return errors;
            // Check if the inputAmount value is enough to cover all the fees.
            const canCoverFeesError = yield this.checkCoverFees(params, estimate);
            if (canCoverFeesError)
                errors.push(canCoverFeesError);
            return errors;
        });
    }
    /**
     *
     * @param params
     * @param estimate
     * @returns
     */
    checkCoverFees(params, estimate) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = undefined;
            const inputInRune = yield this.thorchainCache.convert(params.input, xchainUtil.AssetRuneNative);
            const feesInRune = yield this.getFeesIn(estimate.totalFees, xchainUtil.AssetRuneNative);
            const totalSwapFeesInRune = feesInRune.inboundFee
                .plus(feesInRune.outboundFee)
                .plus(feesInRune.swapFee)
                .plus(feesInRune.affiliateFee);
            const totalSwapFeesInAsset = yield this.thorchainCache.convert(totalSwapFeesInRune, params.input.asset);
            if (totalSwapFeesInRune.gte(inputInRune))
                result = `Input amount ${params.input.formatedAssetString()}(${inputInRune.formatedAssetString()}) is less than or equal to total swap fees ${totalSwapFeesInAsset.formatedAssetString()}(${totalSwapFeesInRune.formatedAssetString()}) `;
            return result;
        });
    }
    /**
     * Convenience method to convert TotalFees to a different CryptoAmount
     *
     * TotalFees are always calculated and returned in RUNE, this method can
     * be used to show the equivalent fees in another Asset Type
     *
     * @param fees: TotalFees - the fees you want to convert
     * @param asset: Asset - the asset you want the fees converted to
     * @returns TotalFees in asset
     */
    getFeesIn(fees, asset) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                inboundFee: yield this.convert(fees.inboundFee, asset),
                swapFee: yield this.convert(fees.swapFee, asset),
                outboundFee: yield this.convert(fees.outboundFee, asset),
                affiliateFee: yield this.convert(fees.affiliateFee, asset),
            };
        });
    }
    /**
     * Returns the exchange of a CryptoAmount to a different Asset
     *
     * Ex. convert(input:100 BUSD, outAsset: BTC) -> 0.0001234 BTC
     *
     * @param input - amount/asset to convert to outAsset
     * @param ouAsset - the Asset you want to convert to
     * @returns CryptoAmount of input
     */
    convert(input, outAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.thorchainCache.convert(input, outAsset);
        });
    }
    /**
     * Finds the required confCount required for an inbound or outbound Tx to THORChain. Estimate based on Midgard data only.
     *
     * Finds the gas asset of the given asset (e.g. BUSD is on BNB), finds the value of asset in Gas Asset then finds the required confirmation count.
     * ConfCount is then times by 6 seconds.
     *
     * @param inbound: CryptoAmount - amount/asset of the outbound amount.
     * @returns time in seconds before a Tx is confirmed by THORChain
     * @see https://docs.thorchain.org/chain-clients/overview
     */
    confCounting(inbound) {
        return __awaiter(this, void 0, void 0, function* () {
            // RUNE, BNB and Synths have near instant finality, so no conf counting required. - need to make a BFT only case.
            if (xchainUtil.isAssetRuneNative(inbound.asset) ||
                inbound.asset.chain == xchainUtil.AssetBNB.chain ||
                inbound.asset.chain == xchainUtil.AssetAtom.chain ||
                inbound.asset.synth) {
                return this.chainAttributes[xchainUtil.Chain.THORChain].avgBlockTimeInSecs;
            }
            // Get the gas asset for the inbound.asset.chain
            const chainGasAsset = getChainAsset(inbound.asset.chain);
            // check for chain asset, else need to convert asset value to chain asset.
            const amountInGasAsset = yield this.thorchainCache.convert(inbound, chainGasAsset);
            // Convert to Asset Amount
            const amountInGasAssetInAsset = amountInGasAsset.assetAmount;
            const confConfig = this.chainAttributes[inbound.asset.chain];
            // find the required confs
            const requiredConfs = Math.ceil(amountInGasAssetInAsset.amount().div(confConfig.blockReward).toNumber());
            // convert that into seconds
            return requiredConfs * confConfig.avgBlockTimeInSecs;
        });
    }
    /**
     * Works out how long an outbound Tx will be held by THORChain before sending.
     *
     * @param outboundAmount: CryptoAmount  being sent.
     * @returns required delay in seconds
     * @see https://gitlab.com/thorchain/thornode/-/blob/develop/x/thorchain/manager_txout_current.go#L548
     */
    outboundDelay(outboundAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const networkValues = yield this.thorchainCache.getNetworkValues();
            const minTxOutVolumeThreshold = new CryptoAmount(xchainUtil.baseAmount(networkValues['MINTXOUTVOLUMETHRESHOLD']), xchainUtil.AssetRuneNative);
            const maxTxOutOffset = networkValues['MAXTXOUTOFFSET'];
            let txOutDelayRate = new CryptoAmount(xchainUtil.baseAmount(networkValues['TXOUTDELAYRATE']), xchainUtil.AssetRuneNative).assetAmount
                .amount()
                .toNumber();
            const getScheduledOutboundValue = yield this.thorchainCache.midgard.getScheduledOutboundValue();
            const thorChainblocktime = this.chainAttributes[xchainUtil.Chain.THORChain].avgBlockTimeInSecs; // blocks required to confirm tx
            // If asset is equal to Rune set runeValue as outbound amount else set it to the asset's value in rune
            const runeValue = yield this.thorchainCache.convert(outboundAmount, xchainUtil.AssetRuneNative);
            // Check rune value amount
            if (runeValue.lt(minTxOutVolumeThreshold)) {
                return thorChainblocktime;
            }
            // Rune value in the outbound queue
            if (getScheduledOutboundValue == undefined) {
                throw new Error(`Could not return Scheduled Outbound Value`);
            }
            // Add OutboundAmount in rune to the oubound queue
            const outboundAmountTotal = runeValue.plus(getScheduledOutboundValue);
            // calculate the if outboundAmountTotal is over the volume threshold
            const volumeThreshold = outboundAmountTotal.div(minTxOutVolumeThreshold);
            // check delay rate
            txOutDelayRate = txOutDelayRate - volumeThreshold.assetAmount.amount().toNumber() <= 1 ? 1 : txOutDelayRate;
            // calculate the minimum number of blocks in the future the txn has to be
            let minBlocks = runeValue.assetAmount.amount().toNumber() / txOutDelayRate;
            minBlocks = minBlocks > maxTxOutOffset ? maxTxOutOffset : minBlocks;
            return minBlocks * thorChainblocktime;
        });
    }
    /**
     * For a given in Tx Hash (as returned by THORChainAMM.DoSwap()), finds the status of any THORChain transaction
     * This function should be polled.
     * @param
     * @param inboundTxHash - needed to determine transactions stage
     * @param sourceChain - extra parameter
     * @returns - object tx status
     */
    checkTx(inboundTxHash, sourceChain) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let txStatus = { stage: exports.TxStage.INBOUND_CHAIN_UNCONFIRMED, seconds: 0 };
            const txData = yield this.thorchainCache.thornode.getTxData(inboundTxHash);
            const scheduledQueueItem = (yield this.thorchainCache.thornode.getscheduledQueue()).find((item) => item.in_hash === inboundTxHash);
            //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
            // Check to see if the transaction has been observed
            if (txData.observed_tx == undefined) {
                txStatus = yield this.checkTxDefined(txStatus, sourceChain);
                return txStatus;
            }
            // If its scheduled and observed
            if (scheduledQueueItem && txData.observed_tx) {
                txStatus = yield this.checkObservedOnly(txStatus, scheduledQueueItem, txData.observed_tx, sourceChain);
            }
            //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
            // Retrieve asset and chain from memo
            const pool = (_a = txData.observed_tx.tx.memo) === null || _a === void 0 ? void 0 : _a.split(`:`);
            if (!pool)
                throw Error(`No pool found from memo`);
            const getAsset = xchainUtil.assetFromString(pool[1].toUpperCase());
            if (!getAsset)
                throw Error(`Invalid pool asset`);
            // Retrieve thorchain blockHeight for the tx
            if (!((_b = txData.observed_tx.tx) === null || _b === void 0 ? void 0 : _b.id))
                throw Error('No action observed');
            const recordedAction = yield this.thorchainCache.midgard.getActions('', txData.observed_tx.tx.id);
            const recordedTCBlock = recordedAction.find((block) => {
                return block;
            });
            if (!(recordedTCBlock === null || recordedTCBlock === void 0 ? void 0 : recordedTCBlock.height))
                throw Error('No recorded block height');
            // Retrieve thorchains last observed block height
            const lastBlock = yield this.thorchainCache.thornode.getLastBlock();
            const lastBlockHeight = lastBlock.find((obj) => obj.chain === (getAsset === null || getAsset === void 0 ? void 0 : getAsset.chain));
            // Check to see if its in the outbound queue
            if (scheduledQueueItem) {
                txStatus = yield this.checkOutboundQueue(txStatus, scheduledQueueItem, lastBlockHeight);
                // Check to see if there is an outbound wait
                if ((scheduledQueueItem === null || scheduledQueueItem === void 0 ? void 0 : scheduledQueueItem.height) != undefined && txStatus.stage < exports.TxStage.OUTBOUND_CHAIN_CONFIRMED) {
                    txStatus = yield this.checkOutboundTx(txStatus, scheduledQueueItem, lastBlockHeight);
                }
                //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
                return txStatus;
            }
            // If not in queue, outbound Tx sent // check synth // check it status == done
            if (!scheduledQueueItem && getAsset) {
                txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_UNCONFIRMED;
                if (getAsset === null || getAsset === void 0 ? void 0 : getAsset.synth) {
                    if (((_c = txData.observed_tx) === null || _c === void 0 ? void 0 : _c.status) == xchainThornode.ObservedTxStatusEnum.Done) {
                        txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_CONFIRMED;
                        txStatus.seconds = 0;
                    }
                    else {
                        txStatus.seconds = 6;
                    }
                    //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
                    return txStatus;
                }
                if (((_d = txData.observed_tx) === null || _d === void 0 ? void 0 : _d.status) == xchainThornode.ObservedTxStatusEnum.Done && getAsset.chain != xchainUtil.Chain.THORChain) {
                    // Retrieve recorded asset block height for the Outbound asset
                    const recordedBlockHeight = yield this.thorchainCache.thornode.getLastBlock(+recordedTCBlock.height);
                    // Match outbound asset to block record
                    const assetBlockHeight = recordedBlockHeight.find((obj) => obj.chain === (getAsset === null || getAsset === void 0 ? void 0 : getAsset.chain));
                    if ((lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.last_observed_in) && (assetBlockHeight === null || assetBlockHeight === void 0 ? void 0 : assetBlockHeight.last_observed_in)) {
                        const chainblockTime = this.chainAttributes[getAsset.chain].avgBlockTimeInSecs;
                        // Difference between current block and the recorded tx block for the outbound asset
                        const blockDifference = lastBlockHeight.last_observed_in - assetBlockHeight.last_observed_in;
                        const timeElapsed = blockDifference * chainblockTime;
                        // If the time elapsed since the tx is greater than the chains block time, assume tx has 1 ocnfirmation else return time left to wait
                        txStatus.seconds = timeElapsed > chainblockTime ? 0 : chainblockTime - timeElapsed;
                        console.log(timeElapsed);
                    }
                    else if (txData.observed_tx.tx.id && (lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.thorchain)) {
                        const recordedAction = yield this.thorchainCache.midgard.getActions(txData.observed_tx.tx.id);
                        const recordedBlockheight = recordedAction.find((block) => {
                            return block;
                        });
                        if (!recordedBlockheight)
                            throw Error(`No height recorded`);
                        const chainblockTime = this.chainAttributes[getAsset.chain].avgBlockTimeInSecs;
                        console.log(chainblockTime);
                        const blockDifference = (lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.thorchain) - +recordedBlockheight.height;
                        console.log(blockDifference);
                        const timeElapsed = (blockDifference * chainblockTime) / this.chainAttributes[getAsset.chain].avgBlockTimeInSecs;
                        txStatus.seconds = timeElapsed > chainblockTime ? 0 : chainblockTime - timeElapsed;
                        console.log(txStatus.seconds);
                        txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_CONFIRMED;
                    }
                    //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
                    return txStatus;
                }
                else {
                    txStatus.seconds = 0;
                    txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_CONFIRMED;
                }
                //console.log(`Tx stage ${txStatus.stage}\nTx seconds left ${txStatus.seconds}`)
                return txStatus;
            }
            else {
                // case example "memo": "OUT:08BC062B248F6F27D0FECEF1650843585A1496BFFEAF7CB17A1CBC30D8D58F9C" where no asset is found its a thorchain tx. Confirms in ~6 seconds
                txStatus.seconds = 0;
                txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_CONFIRMED;
            }
            return txStatus;
        });
    }
    /** Stage 1  */
    checkTxDefined(txStatus, sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            // If there is an error Thornode does not know about it. wait 60 seconds
            // If a long block time like BTC, can check or poll to see if the status changes.
            if (sourceChain) {
                txStatus.seconds = this.chainAttributes[sourceChain].avgBlockTimeInSecs;
            }
            else {
                txStatus.seconds = 60;
            }
            return txStatus;
        });
    }
    /** Stage 2, THORNode has seen it. See if observed only (conf counting) or it has been processed by THORChain  */
    // e.g. https://thornode.ninerealms.com/thorchain/tx/365AC447BE6CE4A55D14143975EE3823A93A0D8DE2B70AECDD63B6A905C3D72B
    checkObservedOnly(txStatus, scheduledQueueItem, observed_tx, sourceChain) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = observed_tx === null || observed_tx === void 0 ? void 0 : observed_tx.tx) === null || _a === void 0 ? void 0 : _a.chain) != undefined) {
                sourceChain = getChain(observed_tx.tx.chain);
            }
            else {
                throw new Error(`Cannot get source chain ${(_b = observed_tx === null || observed_tx === void 0 ? void 0 : observed_tx.tx) === null || _b === void 0 ? void 0 : _b.chain}`);
            }
            //If observed by not final, need to wait till the finalised block before moving to the next stage, blocks in source chain
            if ((observed_tx === null || observed_tx === void 0 ? void 0 : observed_tx.block_height) && (observed_tx === null || observed_tx === void 0 ? void 0 : observed_tx.finalise_height) && scheduledQueueItem.height) {
                if (observed_tx.block_height < observed_tx.finalise_height) {
                    txStatus.stage = exports.TxStage.CONF_COUNTING;
                    const blocksToWait = observed_tx.finalise_height - scheduledQueueItem.height;
                    txStatus.seconds = blocksToWait * this.chainAttributes[sourceChain].avgBlockTimeInSecs;
                }
                else if (observed_tx.status != xchainThornode.ObservedTxStatusEnum.Done) {
                    // processed but not yet full final, e.g. not 2/3 nodes signed
                    txStatus.seconds = this.chainAttributes[xchainUtil.THORChain].avgBlockTimeInSecs; // wait one more TC block
                    txStatus.stage = exports.TxStage.TC_PROCESSING;
                }
            }
            return txStatus;
        });
    }
    /**
     * Stage 3
     * @param txStatus
     * @param txData
     * @param scheduledQueue
     * @param scheduledQueueItem
     * @param lastBlockHeight
     * @returns
     */
    checkOutboundQueue(txStatus, scheduledQueueItem, lastBlockHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the scheduled block is greater than the current block, need to wait that amount of blocks till outbound is sent
            if ((scheduledQueueItem === null || scheduledQueueItem === void 0 ? void 0 : scheduledQueueItem.height) && (lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.thorchain)) {
                if (lastBlockHeight.thorchain < (scheduledQueueItem === null || scheduledQueueItem === void 0 ? void 0 : scheduledQueueItem.height)) {
                    const blocksToWait = scheduledQueueItem.height - lastBlockHeight.thorchain;
                    txStatus.stage = exports.TxStage.OUTBOUND_QUEUED;
                    txStatus.seconds = blocksToWait * this.chainAttributes[xchainUtil.THORChain].avgBlockTimeInSecs;
                    return txStatus;
                }
                else {
                    txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_UNCONFIRMED;
                    return txStatus;
                }
            }
            return txStatus;
        });
    }
    /** Stage 4 */
    checkOutboundTx(txStatus, scheduledQueueItem, lastBlockHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((scheduledQueueItem === null || scheduledQueueItem === void 0 ? void 0 : scheduledQueueItem.height) && (lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.thorchain)) {
                const blockDifference = scheduledQueueItem.height - (lastBlockHeight === null || lastBlockHeight === void 0 ? void 0 : lastBlockHeight.thorchain);
                const timeElapsed = blockDifference * this.chainAttributes[xchainUtil.THORChain].avgBlockTimeInSecs;
                if (blockDifference == 0) {
                    // If Tx has just been sent, Stage 3 should pick this up really
                    txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_UNCONFIRMED;
                    txStatus.seconds = this.chainAttributes[xchainUtil.THORChain].avgBlockTimeInSecs;
                }
                else if (timeElapsed < txStatus.seconds) {
                    // if the time passed since the outbound TX was sent is less than the outbound block time, outbound Tx unconfirmed, wait a bit longer.
                    txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_UNCONFIRMED;
                    txStatus.seconds = this.chainAttributes[xchainUtil.THORChain].avgBlockTimeInSecs - timeElapsed; // workout how long to wait
                }
                else {
                    // time passed is greater than outbound Tx time, Tx is confirmed. Thus stage 5
                    txStatus.stage = exports.TxStage.OUTBOUND_CHAIN_CONFIRMED;
                    txStatus.seconds = 0;
                }
            }
            return txStatus;
        });
    }
    /**
     * Estimates a liquidity position for given crypto amount value, both asymmetrical and symetrical
     * @param params - parameters needed for a estimated liquidity position
     * @returns - type object EstimateLP
     */
    estimateAddLP(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const errors = [];
            if (params.asset.asset.synth || params.rune.asset.synth)
                errors.push('you cannot add liquidity with a synth');
            if (!xchainUtil.isAssetRuneNative(params.rune.asset))
                errors.push('params.rune must be THOR.RUNE');
            const assetPool = yield this.thorchainCache.getPoolForAsset(params.asset.asset);
            const lpUnits = getLiquidityUnits({ asset: params.asset, rune: params.rune }, assetPool);
            const inboundDetails = yield this.thorchainCache.getInboundDetails();
            const unitData = {
                liquidityUnits: lpUnits,
                totalUnits: new bignumber_js.BigNumber(assetPool.pool.liquidityUnits),
            };
            const poolShare = getPoolShare(unitData, assetPool);
            const assetWaitTimeSeconds = yield this.confCounting(params.asset);
            const runeWaitTimeSeconds = yield this.confCounting(params.rune);
            const waitTimeSeconds = assetWaitTimeSeconds > runeWaitTimeSeconds ? assetWaitTimeSeconds : runeWaitTimeSeconds;
            let assetInboundFee = new CryptoAmount(xchainUtil.baseAmount(0), params.asset.asset);
            let runeInboundFee = new CryptoAmount(xchainUtil.baseAmount(0), xchainUtil.AssetRuneNative);
            if (!params.asset.assetAmount.eq(0)) {
                assetInboundFee = calcNetworkFee(params.asset.asset, inboundDetails[params.asset.asset.chain]);
                if (assetInboundFee.assetAmount.amount().times(3).gt(params.asset.assetAmount.amount()))
                    errors.push(`Asset amount is less than fees`);
            }
            if (!params.rune.assetAmount.eq(0)) {
                runeInboundFee = calcNetworkFee(params.rune.asset, inboundDetails[params.rune.asset.chain]);
                if (runeInboundFee.assetAmount.amount().times(3).gt(params.rune.assetAmount.amount()))
                    errors.push(`Rune amount is less than fees`);
            }
            const totalFees = (yield this.convert(assetInboundFee, xchainUtil.AssetRuneNative)).plus(runeInboundFee);
            const slip = getSlipOnLiquidity({ asset: params.asset, rune: params.rune }, assetPool);
            const estimateLP = {
                assetPool: assetPool.pool.asset,
                slipPercent: slip.times(100),
                poolShare: poolShare,
                lpUnits: xchainUtil.baseAmount(lpUnits),
                runeToAssetRatio: assetPool.runeToAssetRatio,
                transactionFee: {
                    assetFee: assetInboundFee,
                    runeFee: runeInboundFee,
                    totalFees: totalFees,
                },
                estimatedWaitSeconds: waitTimeSeconds,
                errors,
                canAdd: errors.length > 0 ? false : true,
            };
            return estimateLP;
        });
    }
    /**
     * @param - Asset for lp
     * @param address - address used for Lp
     * @returns - Type Object liquidityPosition
     */
    checkLiquidityPosition(asset, assetOrRuneAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolAsset = yield this.thorchainCache.getPoolForAsset(asset);
            if (!poolAsset)
                throw Error(`Could not find pool for ${asset}`);
            if (!assetOrRuneAddress)
                throw Error(`No address provided ${assetOrRuneAddress}`);
            const liquidityProvider = yield this.thorchainCache.thornode.getLiquidityProvider(poolAsset.assetString, assetOrRuneAddress);
            if (!liquidityProvider)
                throw Error(`Could not find LP for ${assetOrRuneAddress}`);
            // Current block number for that chain
            const blockData = (yield this.thorchainCache.thornode.getLastBlock()).find((item) => item.chain === asset.chain);
            if (!blockData)
                throw Error(`Could not get block data`);
            // Pools total units & Lp's total units
            const unitData = {
                totalUnits: new bignumber_js.BigNumber(poolAsset.pool.liquidityUnits),
                liquidityUnits: new bignumber_js.BigNumber(liquidityProvider.units),
            };
            //console.log(`unit data`, unitData.totalUnits.amount().toNumber(), unitData.liquidityUnits.amount().toNumber())
            const networkValues = yield this.thorchainCache.midgard.getNetworkValues();
            const block = {
                current: blockData.thorchain,
                lastAdded: liquidityProvider.last_add_height,
                fullProtection: networkValues['FULLIMPLOSSPROTECTIONBLOCKS'],
            };
            //
            const currentLP = {
                asset: xchainUtil.baseAmount(liquidityProvider.asset_deposit_value),
                rune: xchainUtil.baseAmount(liquidityProvider.rune_deposit_value),
            };
            const poolShare = getPoolShare(unitData, poolAsset);
            // console.log(poolShare.assetShare.toNumber(), poolShare.runeShare.toNumber())
            // console.log(poolAsset.pool.liquidityUnits)
            const impermanentLossProtection = getLiquidityProtectionData(currentLP, poolShare, block);
            const lpPosition = {
                poolShare,
                position: liquidityProvider,
                impermanentLossProtection: impermanentLossProtection,
            };
            return lpPosition;
        });
    }
    /**
     * Do not send assetNativeRune, There is no pool for it.
     * @param asset - asset required to find the pool
     * @returns - object type ratios
     */
    getPoolRatios(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetPool = yield this.thorchainCache.getPoolForAsset(asset);
            const poolRatio = {
                assetToRune: assetPool.assetToRuneRatio,
                runeToAsset: assetPool.runeToAssetRatio,
            };
            return poolRatio;
        });
    }
    /**
     *
     * @param params
     */
    estimateWithdrawLP(params) {
        return __awaiter(this, void 0, void 0, function* () {
            // Caution Dust Limits: BTC,BCH,LTC chains 10k sats; DOGE 1m Sats; ETH 0 wei; THOR 0 RUNE.
            const assetOrRuneAddress = params.assetAddress ? params.assetAddress : params.runeAddress;
            const memberDetail = yield this.checkLiquidityPosition(params.asset, assetOrRuneAddress);
            const dustValues = yield this.getDustValues(params.asset); // returns asset and rune dust values
            const assetPool = yield this.thorchainCache.getPoolForAsset(params.asset);
            // get pool share from unit data
            const poolShare = getPoolShare({
                liquidityUnits: new bignumber_js.BigNumber(memberDetail.position.units),
                totalUnits: new bignumber_js.BigNumber(assetPool.pool.liquidityUnits),
            }, assetPool);
            // calculate total fees
            const totalFees = (yield this.convert(dustValues.asset, xchainUtil.AssetRuneNative)).plus(dustValues.rune);
            // get slip on liquidity removal
            const slip = getSlipOnLiquidity({
                asset: poolShare.assetShare,
                rune: poolShare.runeShare,
            }, assetPool);
            // TODO make sure we compare wait times for withdrawing both rune and asset OR just rune OR just asset
            const waitTimeSecondsForAsset = yield this.confCounting(poolShare.assetShare.div(params.percentage / 100));
            const waitTimeSecondsForRune = yield this.confCounting(poolShare.runeShare.div(params.percentage / 100));
            let waitTimeSeconds = 0;
            if (params.assetAddress && params.runeAddress) {
                waitTimeSeconds = waitTimeSecondsForAsset + waitTimeSecondsForRune;
            }
            else if (params.assetAddress) {
                waitTimeSeconds = waitTimeSecondsForAsset;
            }
            else {
                waitTimeSeconds = waitTimeSecondsForRune;
            }
            const estimateLP = {
                assetAddress: memberDetail.position.asset_address,
                runeAddress: memberDetail.position.rune_address,
                slipPercent: slip.times(100),
                transactionFee: {
                    assetFee: dustValues.asset,
                    runeFee: dustValues.rune,
                    totalFees: totalFees,
                },
                assetAmount: poolShare.assetShare,
                runeAmount: poolShare.runeShare,
                estimatedWaitSeconds: waitTimeSeconds,
                impermanentLossProtection: memberDetail.impermanentLossProtection,
                assetPool: assetPool.pool.asset,
            };
            return estimateLP;
        });
    }
    /**
     * // can this become a quried constant? added to inbound_addresses or something
     * @param asset - asset needed to retrieve dust values
     * @returns - object type dust values
     */
    getDustValues(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            let dustValues;
            switch (asset.chain) {
                case 'BNB':
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0.000001)), xchainUtil.AssetBNB),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                case 'BTC'  :
                    // 10k sats
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0.0001)), asset),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                case 'ETH':
                    // 0 wei
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), asset),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                case 'THOR':
                    // 0 Rune
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), asset),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                case 'GAIA':
                    // 0 GAIA
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), asset),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                case 'DOGE':
                    // 1 million sats
                    dustValues = {
                        asset: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0.01)), asset),
                        rune: new CryptoAmount(xchainUtil.assetToBase(xchainUtil.assetAmount(0)), xchainUtil.AssetRuneNative),
                    };
                    return dustValues;
                default:
                    throw Error('Unknown chain');
            }
        });
    }
}

exports.CryptoAmount = CryptoAmount;
exports.LiquidityPool = LiquidityPool;
exports.Midgard = Midgard;
exports.ThorchainCache = ThorchainCache;
exports.ThorchainQuery = ThorchainQuery;
exports.Thornode = Thornode;
exports.calcNetworkFee = calcNetworkFee;
exports.getDoubleSwap = getDoubleSwap;
exports.getLiquidityProtectionData = getLiquidityProtectionData;
exports.getLiquidityUnits = getLiquidityUnits;
exports.getPoolShare = getPoolShare;
exports.getSingleSwap = getSingleSwap;
exports.getSlipOnLiquidity = getSlipOnLiquidity;
