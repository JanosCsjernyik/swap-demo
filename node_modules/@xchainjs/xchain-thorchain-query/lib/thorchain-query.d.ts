import { Asset, Chain } from '@xchainjs/xchain-util';
import { CryptoAmount } from './crypto-amount';
import { ThorchainCache } from './thorchain-cache';
import { AddliquidityPosition, ChainAttributes, EstimateAddLP, EstimateSwapParams, EstimateWithdrawLP, LiquidityPosition, PoolRatios, TotalFees, TxDetails, TxStatus, WithdrawLiquidityPosition } from './types';
/**
 * THORChain Class for interacting with THORChain.
 * Recommended main class to use for swapping with THORChain
 * Has access to Midgard and THORNode data
 */
export declare class ThorchainQuery {
    readonly thorchainCache: ThorchainCache;
    private chainAttributes;
    /**
     * Contructor to create a ThorchainAMM
     *
     * @param thorchainCache - an instance of the ThorchainCache (could be pointing to stagenet,testnet,mainnet)
     * @param chainAttributes - atrributes used to calculate waitTime & conf counting
     * @returns ThorchainAMM
     */
    constructor(thorchainCache?: ThorchainCache, chainAttributes?: Record<Chain, ChainAttributes>);
    /**
     * Provides a swap estimate for the given swap detail. Will check the params for errors before trying to get the estimate.
     * Uses current pool data, works out inbound and outboud fee, affiliate fees and works out the expected wait time for the swap (in and out)
     *
     * @param params - amount to swap
  
     * @returns The SwapEstimate
     */
    estimateSwap({ input, destinationAsset, destinationAddress, affiliateAddress, interfaceID, affiliateFeePercent, slipLimit, }: EstimateSwapParams): Promise<TxDetails>;
    /**
     * Basic Checks for swap information
     * @param params
     */
    private isValidSwap;
    /**
     * Does the calculations for the swap.
     * Used by estimateSwap
     *
     * @param params
     * @param sourceInboundDetails
     * @param destinationInboundDetails
     * @param sourcePool
     * @param destinationPool
     * @returns
     */
    private calcSwapEstimate;
    /**
     *
     * @param params - swap object
     * @returns - constructed memo string
     */
    private constructSwapMemo;
    /**
     * Looks for errors or issues within swap prams before doing the swap.
     *
     *
     * @param params
     * @param estimate
     * @param sourcePool
     * @param sourceInboundDetails
     * @param destinationPool
     * @param destinationInboundDetails
     * @returns
     */
    private getSwapEstimateErrors;
    /**
     *
     * @param params
     * @param estimate
     * @returns
     */
    private checkCoverFees;
    /**
     * Convenience method to convert TotalFees to a different CryptoAmount
     *
     * TotalFees are always calculated and returned in RUNE, this method can
     * be used to show the equivalent fees in another Asset Type
     *
     * @param fees: TotalFees - the fees you want to convert
     * @param asset: Asset - the asset you want the fees converted to
     * @returns TotalFees in asset
     */
    getFeesIn(fees: TotalFees, asset: Asset): Promise<TotalFees>;
    /**
     * Returns the exchange of a CryptoAmount to a different Asset
     *
     * Ex. convert(input:100 BUSD, outAsset: BTC) -> 0.0001234 BTC
     *
     * @param input - amount/asset to convert to outAsset
     * @param ouAsset - the Asset you want to convert to
     * @returns CryptoAmount of input
     */
    convert(input: CryptoAmount, outAsset: Asset): Promise<CryptoAmount>;
    /**
     * Finds the required confCount required for an inbound or outbound Tx to THORChain. Estimate based on Midgard data only.
     *
     * Finds the gas asset of the given asset (e.g. BUSD is on BNB), finds the value of asset in Gas Asset then finds the required confirmation count.
     * ConfCount is then times by 6 seconds.
     *
     * @param inbound: CryptoAmount - amount/asset of the outbound amount.
     * @returns time in seconds before a Tx is confirmed by THORChain
     * @see https://docs.thorchain.org/chain-clients/overview
     */
    confCounting(inbound: CryptoAmount): Promise<number>;
    /**
     * Works out how long an outbound Tx will be held by THORChain before sending.
     *
     * @param outboundAmount: CryptoAmount  being sent.
     * @returns required delay in seconds
     * @see https://gitlab.com/thorchain/thornode/-/blob/develop/x/thorchain/manager_txout_current.go#L548
     */
    outboundDelay(outboundAmount: CryptoAmount): Promise<number>;
    /**
     * For a given in Tx Hash (as returned by THORChainAMM.DoSwap()), finds the status of any THORChain transaction
     * This function should be polled.
     * @param
     * @param inboundTxHash - needed to determine transactions stage
     * @param sourceChain - extra parameter
     * @returns - object tx status
     */
    checkTx(inboundTxHash: string, sourceChain?: Chain): Promise<TxStatus>;
    /** Stage 1  */
    private checkTxDefined;
    /** Stage 2, THORNode has seen it. See if observed only (conf counting) or it has been processed by THORChain  */
    private checkObservedOnly;
    /**
     * Stage 3
     * @param txStatus
     * @param txData
     * @param scheduledQueue
     * @param scheduledQueueItem
     * @param lastBlockHeight
     * @returns
     */
    private checkOutboundQueue;
    /** Stage 4 */
    private checkOutboundTx;
    /**
     * Estimates a liquidity position for given crypto amount value, both asymmetrical and symetrical
     * @param params - parameters needed for a estimated liquidity position
     * @returns - type object EstimateLP
     */
    estimateAddLP(params: AddliquidityPosition): Promise<EstimateAddLP>;
    /**
     * @param - Asset for lp
     * @param address - address used for Lp
     * @returns - Type Object liquidityPosition
     */
    checkLiquidityPosition(asset: Asset, assetOrRuneAddress?: string): Promise<LiquidityPosition>;
    /**
     * Do not send assetNativeRune, There is no pool for it.
     * @param asset - asset required to find the pool
     * @returns - object type ratios
     */
    getPoolRatios(asset: Asset): Promise<PoolRatios>;
    /**
     *
     * @param params
     */
    estimateWithdrawLP(params: WithdrawLiquidityPosition): Promise<EstimateWithdrawLP>;
    /**
     * // can this become a quried constant? added to inbound_addresses or something
     * @param asset - asset needed to retrieve dust values
     * @returns - object type dust values
     */
    private getDustValues;
}
